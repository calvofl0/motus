<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motus - File Transfer Interface</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <!-- Stylesheets -->
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/header.css">
    <link rel="stylesheet" href="/css/easy-mode-layout.css">
    <link rel="stylesheet" href="/css/expert-mode.css">
    <link rel="stylesheet" href="/css/context-menu.css">
    <link rel="stylesheet" href="/css/jobs.css">
    <link rel="stylesheet" href="/css/modals.css">
</head>
<body>
    <!-- Header (shared between modes) -->
    <div class="header">
        <div class="header-left">
            <h1>Motus</h1>
            <p class="subtitle"><em>Motus et bouche cousue</em> ‚Äî A Web-based File Transfer Interface</p>
        </div>
        <div class="header-right">
            <button class="manage-remotes-button" id="manage-remotes-btn">
                Manage Remotes
            </button>
            <div class="view-dropdown-container">
                <button class="view-toggle-button" id="view-menu-btn">
                    View ‚ñæ
                </button>
                <div class="view-dropdown-menu hidden" id="view-dropdown">
                    <div class="view-menu-item" id="view-mode-option">
                        <span id="view-mode-icon">‚äû</span> <span id="view-mode-text">Grid layout</span>
                    </div>
                    <div class="view-menu-item" id="hidden-files-option">
                        <span id="hidden-files-text">Show hidden files</span>
                    </div>
                </div>
            </div>
            <button class="mode-toggle-button" id="mode-toggle-btn">
                <span id="mode-button-text">Expert Mode</span>
            </button>
            <button class="quit-button" id="quit-btn">Quit</button>
        </div>
    </div>

    <!-- Easy Mode -->
    <div id="easy-mode">
        <div class="panes-container">
            <!-- Left Pane -->
            <div class="pane left-pane">
                <div class="pane-header">üìÇ Server A</div>
                <div class="pane-toolbar">
                    <div class="toolbar-row">
                        <select id="left-remote">
                            <option value="">Local Filesystem</option>
                        </select>
                    </div>
                    <div class="toolbar-row">
                        <input type="text" id="left-path" value="/" placeholder="Path..." />
                        <button id="left-refresh-btn" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #28a745; padding: 8px; transition: transform 0.2s;" title="Refresh">‚ü≥</button>
                    </div>
                </div>
                <div class="file-grid" id="left-files">
                    <!-- Files will be populated here -->
                </div>
            </div>

            <!-- Arrow Buttons -->
            <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 20px; padding: 0 15px;">
                <div id="copy-right-btn" style="color: #28a745; font-size: 28px; cursor: not-allowed; transition: all 0.3s; opacity: 0.3; user-select: none;" title="Copy selected files to right pane">‚ñ∂</div>
                <div id="copy-left-btn" style="color: #28a745; font-size: 28px; cursor: not-allowed; transition: all 0.3s; opacity: 0.3; user-select: none;" title="Copy selected files to left pane">‚óÄ</div>
            </div>

            <!-- Right Pane -->
            <div class="pane right-pane">
                <div class="pane-header">üìÇ Server B</div>
                <div class="pane-toolbar">
                    <div class="toolbar-row">
                        <select id="right-remote">
                            <option value="">Local Filesystem</option>
                        </select>
                    </div>
                    <div class="toolbar-row">
                        <input type="text" id="right-path" value="/" placeholder="Path..." />
                        <button id="right-refresh-btn" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #28a745; padding: 8px; transition: transform 0.2s;" title="Refresh">‚ü≥</button>
                    </div>
                </div>
                <div class="file-grid" id="right-files">
                    <!-- Files will be populated here -->
                </div>
            </div>
        </div>

        <!-- Collapsible Job Panel -->
        <div class="job-panel collapsed" id="job-panel">
            <div class="job-panel-header" id="job-panel-header">
                <span class="job-panel-title">üìä Active Jobs (<span id="job-count">0</span>)</span>
                <span class="collapse-icon">‚ñº</span>
            </div>
            <div class="job-list" id="job-list">
                <!-- Jobs will be populated here -->
            </div>
        </div>

        <!-- Interrupted Jobs Dropdown -->
        <div class="interrupted-jobs-dropdown hidden" id="interrupted-jobs-dropdown">
            <div class="interrupted-jobs-header" id="interrupted-jobs-header">
                <span>‚ö†Ô∏è Interrupted Jobs (<span id="interrupted-count">0</span>)</span>
                <span class="collapse-icon">‚ñº</span>
            </div>
            <div class="interrupted-jobs-list hidden" id="interrupted-jobs-list">
                <!-- Interrupted jobs will be populated here -->
            </div>
        </div>

        <!-- Failed Jobs Dropdown -->
        <div class="failed-jobs-dropdown hidden" id="failed-jobs-dropdown">
            <div class="failed-jobs-header" id="failed-jobs-header">
                <span>‚ùå Failed Jobs (<span id="failed-count">0</span>)</span>
                <span class="collapse-icon">‚ñº</span>
            </div>
            <div class="failed-jobs-list hidden" id="failed-jobs-list">
                <!-- Failed jobs will be populated here -->
            </div>
        </div>
    </div>

    <!-- Expert Mode (existing UI) -->
    <div id="expert-mode" class="hidden">
        <div class="container" style="margin-top: 0;">
            <!-- Authentication -->
            <div class="section">
                <h2>üîê Authentication</h2>
                <div class="form-group">
                    <label>Access Token:</label>
                    <input type="text" id="token" placeholder="Enter your token (check server logs)" />
                    <div class="hint">The token is displayed when you start the server</div>
                </div>
                <button id="expert-auth-btn">Authenticate</button>
                <div id="auth-status"></div>
            </div>

            <!-- Available Remotes -->
            <div class="section">
                <h2>üåê Available Remotes</h2>
                <div class="hint">
                    Configure remotes using: <code>rclone config</code><br>
                    List remotes using: <code>rclone listremotes</code>
                </div>
                <button id="expert-list-remotes-btn">List Remotes</button>
                <div class="output" id="remotes-output"></div>
            </div>

            <!-- File Operations -->
            <div class="section">
                <h2>üìÅ File Operations</h2>

                <div class="form-group">
                    <label>Path:</label>
                    <input type="text" id="ls-path" placeholder="/path or remote:/path" value="/" />
                    <div class="hint">Example: /tmp or myS3:/bucket/folder</div>
                </div>
                <button id="expert-list-files-btn">List Files</button>
                <div class="output" id="ls-output"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <div class="form-group">
                    <label>Create Directory:</label>
                    <input type="text" id="mkdir-path" placeholder="/path/to/newdir or remote:/path/newdir" />
                </div>
                <button id="expert-mkdir-btn">Create Directory</button>
                <div id="mkdir-status"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <div class="form-group">
                    <label>Delete Path:</label>
                    <input type="text" id="delete-path" placeholder="/path or remote:/path" />
                </div>
                <button id="expert-delete-btn" style="background: #dc3545;">Delete</button>
                <div id="delete-status"></div>
            </div>

            <!-- Job Management -->
            <div class="section">
                <h2>üì¶ Job Management</h2>
                
                <div class="form-group">
                    <label>Source Path:</label>
                    <input type="text" id="job-src" placeholder="/source or remote:/source" />
                </div>
                <div class="form-group">
                    <label>Destination Path:</label>
                    <input type="text" id="job-dst" placeholder="/destination or remote:/destination" />
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="copy-links" /> Follow Symlinks
                    </label>
                </div>
                <button id="expert-copy-btn">Copy</button>
                <button id="expert-move-btn" style="background: #ffc107; color: #000;">Move</button>
                <button id="expert-integrity-btn" style="background: #17a2b8;">Check Integrity</button>
                <button id="expert-sync-btn" style="background: #dc3545;">Sync (Destructive)</button>
                <div id="job-start-status"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <div class="form-group">
                    <label>Job ID:</label>
                    <input type="number" id="job-id" placeholder="Enter job ID" />
                    <div class="hint">Press ENTER to get status</div>
                </div>
                <button id="expert-job-status-btn">Get Status</button>
                <button id="expert-watch-progress-btn" style="background: #17a2b8;">Watch Progress (SSE)</button>
                <button id="expert-stop-watch-btn" style="background: #6c757d; display: none;">Stop Watching</button>
                <button id="expert-show-log-btn" style="background: #6c757d;">Show Log</button>
                <button id="expert-resume-btn" style="background: #28a745;">Resume</button>
                <button id="expert-stop-job-btn" style="background: #dc3545;">Stop Job</button>
                <div class="output" id="job-status-output"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <button id="expert-list-all-btn">List All Jobs</button>
                <button id="expert-list-running-btn" style="background: #28a745;">List Running</button>
                <button id="expert-list-aborted-btn" style="background: #ffc107; color: #000;">List Aborted</button>
                <button id="expert-clear-stopped-btn" style="background: #6c757d;">Clear All Stopped Jobs</button>
                <div class="output" id="all-jobs-output"></div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" data-action="newfolder">üìÅ Create Folder</div>
        <div class="context-menu-item" data-action="rename">‚úèÔ∏è Rename</div>
        <div class="context-menu-item danger" data-action="delete">üóëÔ∏è Delete</div>
        <div class="context-menu-item has-submenu">
            üìä Sort by
            <div class="context-submenu">
                <div class="context-menu-item" data-sort="name" data-asc="true">Name (A-Z)</div>
                <div class="context-menu-item" data-sort="name" data-asc="false">Name (Z-A)</div>
                <div class="context-menu-item" data-sort="size" data-asc="true">Size (Smallest)</div>
                <div class="context-menu-item" data-sort="size" data-asc="false">Size (Largest)</div>
                <div class="context-menu-item" data-sort="date" data-asc="true">Date (Oldest)</div>
                <div class="context-menu-item" data-sort="date" data-asc="false">Date (Newest)</div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="interrupted-jobs-modal">
        <div class="modal-content">
            <div class="modal-header">‚ö†Ô∏è Interrupted Jobs Found</div>
            <p>Some jobs were interrupted when the server was last stopped. Would you like to resume them?</p>
            <div id="interrupted-jobs-list"></div>
            <div class="modal-buttons">
                <button id="interrupted-jobs-skip-btn">Skip</button>
                <button id="interrupted-jobs-resume-all-btn" style="background: #28a745;">Resume All</button>
            </div>
        </div>
    </div>

    <div class="modal" id="rename-modal">
        <div class="modal-content">
            <div class="modal-header">‚úèÔ∏è Rename</div>
            <div class="form-group">
                <label>New name:</label>
                <input type="text" id="rename-input" />
            </div>
            <div class="modal-buttons">
                <button id="rename-cancel-btn">Cancel</button>
                <button id="rename-confirm-btn" style="background: #28a745;">Rename</button>
            </div>
        </div>
    </div>

    <div class="modal" id="create-folder-modal">
        <div class="modal-content">
            <div class="modal-header">üìÅ Create New Folder</div>
            <div class="form-group">
                <label>Folder name:</label>
                <input type="text" id="create-folder-input" />
            </div>
            <div class="modal-buttons">
                <button id="create-folder-cancel-btn">Cancel</button>
                <button id="create-folder-confirm-btn" style="background: #28a745;">Create</button>
            </div>
        </div>
    </div>

    <div class="modal" id="delete-confirm-modal">
        <div class="modal-content">
            <div class="modal-header">‚ö†Ô∏è Confirm Delete</div>
            <p style="margin-bottom: 15px; color: #dc3545; font-weight: 500;">
                This action is irreversible! There is no recycle bin.
            </p>
            <p id="delete-confirm-message">Are you sure you want to delete the selected items?</p>
            <div class="modal-buttons">
                <button id="delete-cancel-btn">Cancel</button>
                <button id="delete-confirm-btn" style="background: #dc3545;">Delete</button>
            </div>
        </div>
    </div>

    <!-- Drag and Drop Confirmation Modal -->
    <div class="modal" id="drag-drop-confirm-modal">
        <div class="modal-content">
            <div class="modal-header">üìã Confirm Copy Operation</div>
            <p style="margin-bottom: 15px; color: #333; font-weight: 500;">
                Copy the following files?
            </p>
            <div style="margin-bottom: 15px; background: #f8f9fa; padding: 12px; border-radius: 6px; max-height: 200px; overflow-y: auto;">
                <div id="drag-drop-file-list" style="font-family: monospace; font-size: 12px; color: #333;"></div>
            </div>
            <div style="margin-bottom: 15px; background: #e3f2fd; padding: 12px; border-radius: 6px;">
                <div style="font-weight: 600; color: #1976d2; margin-bottom: 8px;">Source:</div>
                <div id="drag-drop-source" style="font-family: monospace; font-size: 12px; color: #333; word-break: break-all;"></div>
            </div>
            <div style="margin-bottom: 20px; background: #e8f5e9; padding: 12px; border-radius: 6px;">
                <div style="font-weight: 600; color: #388e3c; margin-bottom: 8px;">Destination:</div>
                <div id="drag-drop-destination" style="font-family: monospace; font-size: 12px; color: #333; word-break: break-all;"></div>
            </div>
            <div class="modal-buttons">
                <button id="drag-drop-cancel-btn">Cancel</button>
                <button id="drag-drop-confirm-btn" style="background: #28a745;">Copy</button>
            </div>
        </div>
    </div>

    <!-- Upload Progress Modal -->
    <div class="modal" id="upload-progress-modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">üì§ Uploading Files</div>
            <div style="margin-bottom: 15px; color: #333;">
                <div id="upload-progress-message" style="font-weight: 500; margin-bottom: 10px;">
                    Preparing upload...
                </div>
                <div style="background: #f0f0f0; border-radius: 10px; height: 24px; overflow: hidden; position: relative;">
                    <div id="upload-progress-bar" style="background: linear-gradient(90deg, #28a745, #20c997); height: 100%; width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center;">
                        <span id="upload-progress-percent" style="color: white; font-weight: bold; font-size: 12px; position: absolute; left: 50%; transform: translateX(-50%); text-shadow: 0 0 3px rgba(0,0,0,0.3);">0%</span>
                    </div>
                </div>
                <div id="upload-progress-details" style="font-size: 12px; color: #666; margin-top: 8px;">
                    <!-- Details like file count, speed, etc. -->
                </div>
            </div>
            <div class="modal-buttons">
                <button id="upload-cancel-btn" style="background: #dc3545;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Manage Remotes Modal -->
    <div class="modal" id="manage-remotes-modal">
        <div class="modal-content" style="max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
            <!-- Step 1: List Remotes -->
            <div id="manage-remotes-step1" class="manage-remotes-step" style="display: flex; flex-direction: column; max-height: 80vh;">
                <div class="modal-header" style="position: relative;">
                    üîß Manage Remotes
                    <button id="manage-remotes-close-btn" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close">√ó</button>
                </div>
                <div id="remotes-list-container" style="margin-bottom: 15px; overflow-y: auto; max-height: 50vh;">
                    <p style="color: #666; text-align: center;">Loading remotes...</p>
                </div>
                <div class="modal-buttons">
                    <button id="add-remote-btn" style="background: #28a745; display: none;">+ Add Remote</button>
                </div>
            </div>

            <!-- Step 2: Select Template -->
            <div id="manage-remotes-step2" class="manage-remotes-step" style="display: none; flex-direction: column; max-height: 80vh;">
                <div class="modal-header" style="position: relative;">
                    üìã Select Template
                    <button id="template-close-btn" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close and return to remotes list">√ó</button>
                </div>
                <p style="margin-bottom: 15px; color: #666;">Choose a template for the new remote:</p>
                <div id="templates-list-container" style="overflow-y: auto; max-height: 50vh; margin-bottom: 15px;">
                    <p style="color: #666; text-align: center;">Loading templates...</p>
                </div>
                <div class="modal-buttons">
                    <button id="template-next-btn" style="background: #007bff;" disabled>Next</button>
                </div>
            </div>

            <!-- Step 3: Configure Remote -->
            <div id="manage-remotes-step3" class="manage-remotes-step" style="display: none; flex-direction: column; max-height: 80vh;">
                <div class="modal-header" style="position: relative;">
                    ‚öôÔ∏è Configure Remote
                    <button id="configure-close-btn" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close and return to remotes list">√ó</button>
                </div>
                <div id="remote-form-container" style="overflow-y: auto; max-height: 50vh; margin-bottom: 15px;">
                    <!-- Form will be generated dynamically -->
                </div>
                <div class="modal-buttons">
                    <button id="configure-back-btn">Back</button>
                    <button id="create-remote-btn" style="background: #28a745;">Create Remote</button>
                </div>
            </div>
        </div>
    </div>

    <!-- View Remote Config Modal -->
    <div class="modal" id="view-remote-config-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header" style="position: relative;">
                üìÑ Remote Configuration
                <button id="view-remote-close-btn" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close">√ó</button>
            </div>
            <div id="remote-config-content" style="margin-bottom: 15px; max-height: 50vh; overflow-y: auto;">
                <!-- Config will be populated here -->
            </div>
            <div class="modal-buttons">
                <button id="copy-remote-config-btn" style="background: #28a745; position: relative;">
                    üìã Copy to Clipboard
                    <span id="copy-tooltip" style="display: none; position: absolute; top: -30px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap;">Copied!</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Edit Remote Config Modal -->
    <div class="modal" id="edit-remote-config-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">‚úèÔ∏è Edit Remote Configuration</div>
            <div style="margin-bottom: 15px;">
                <p style="color: #666; margin-bottom: 10px;">Edit the rclone configuration for this remote. You can rename the remote by changing the value between [brackets].</p>
                <textarea id="edit-remote-config-text"
                          style="width: 100%; min-height: 300px; max-height: 50vh; font-family: monospace; font-size: 12px; padding: 12px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"
                          placeholder="[remote_name]
type = s3
..."></textarea>
            </div>
            <div class="modal-buttons">
                <button id="edit-remote-cancel-btn">Cancel</button>
                <button id="edit-remote-save-btn" style="background: #28a745;">Save</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import modules
        import { ModalManager, initModalManager } from '/js/lib/modal-manager.js';
        import { state, getPaneState, setPanePath, setPaneRemote, setPaneFiles, clearPaneSelection, togglePaneSort, getSelectedFiles, getPaneFullPath, setViewMode, toggleShowHiddenFiles, setLastFocusedPane } from '/js/config.js';
        import { apiCall, setAuthToken, getAuthToken, clearAuthToken, isAuthenticated } from '/js/lib/api.js';
        import { buildPath, sortFiles, formatFileSize, formatFileDate, expandTildePath, resolveRelativePath, buildFullPath, parseRemotePath } from '/js/utils/helpers.js';
        import { savePreferences as savePrefs, loadPreferences as loadPrefs } from '/js/utils/preferences.js';
        import { JobProgressWatcher } from '/js/lib/sse.js';
        import { RemoteManager } from '/js/modules/remote-manager.js';

        // Make ModalManager available globally for compatibility
        window.ModalManager = ModalManager;

        // Use state from config.js instead of local variables
        // Aliases for convenience (will be refactored away gradually)
        let currentMode = state.currentMode;
        let authToken = '';  // Keep local for compatibility, sync with api.js
        let leftPaneState = state.panes.left;
        let rightPaneState = state.panes.right;
        let viewMode = state.ui.viewMode;
        let showHiddenFiles = state.ui.showHiddenFiles;
        let lastFocusedPane = state.ui.lastFocusedPane;
        let contextMenuState = state.contextMenu;
        let jobsData = state.jobs.active;
        let interruptedJobsData = state.jobs.interrupted;
        let failedJobsData = state.jobs.failed;
        let jobUpdateInterval = state.jobs.updateInterval;
        let interruptedJobsInterval = state.jobs.interruptedInterval;
        let failedJobsInterval = state.jobs.failedInterval;
        let createFolderPane = state.createFolder.pane;
        let jobPanelManuallyToggled = state.jobs.panelManuallyToggled;
        let previousJobState = state.jobs.previousState;
        let trackedJobs = state.jobs.tracked;
        let pendingDragDrop = state.dragDrop.pending;
        let uploadAbortController = state.upload.abortController;
        let uploadStartTime = state.upload.startTime;
        let maxUploadSize = state.upload.maxSize;

        // Initialize modules
        const remoteManager = new RemoteManager(apiCall, ModalManager, {
            onRemotesChanged: async () => {
                await loadRemotes();
                await refreshPane('left');
                await refreshPane('right');
            },
            getActivePanes: () => ({
                left: leftPaneState.remote,
                right: rightPaneState.remote
            }),
            onOAuthRefresh: (remoteName) => refreshOAuthToken(remoteName)
        });

        // Initialize
        // Setup all event listeners (proper pattern instead of inline handlers)
        function setupEventListeners() {
            // Header buttons
            document.getElementById('manage-remotes-btn').addEventListener('click', () => remoteManager.open());
            document.getElementById('view-menu-btn').addEventListener('click', toggleViewMenu);
            document.getElementById('view-mode-option').addEventListener('click', switchViewMode);
            document.getElementById('hidden-files-option').addEventListener('click', toggleHiddenFilesOption);
            document.getElementById('mode-toggle-btn').addEventListener('click', toggleMode);
            document.getElementById('quit-btn').addEventListener('click', quitServer);

            // Left pane controls
            document.getElementById('left-remote').addEventListener('change', () => onRemoteChange('left'));
            document.getElementById('left-path').addEventListener('keypress', (e) => handlePathKeypress(e, 'left'));
            document.getElementById('left-refresh-btn').addEventListener('click', () => refreshPane('left', true));
            document.getElementById('left-refresh-btn').addEventListener('mouseover', function() {
                this.style.transform = 'scale(1.2)';
            });
            document.getElementById('left-refresh-btn').addEventListener('mouseout', function() {
                this.style.transform = 'scale(1)';
            });

            // Right pane controls
            document.getElementById('right-remote').addEventListener('change', () => onRemoteChange('right'));
            document.getElementById('right-path').addEventListener('keypress', (e) => handlePathKeypress(e, 'right'));
            document.getElementById('right-refresh-btn').addEventListener('click', () => refreshPane('right', true));
            document.getElementById('right-refresh-btn').addEventListener('mouseover', function() {
                this.style.transform = 'scale(1.2)';
            });
            document.getElementById('right-refresh-btn').addEventListener('mouseout', function() {
                this.style.transform = 'scale(1)';
            });

            // Arrow buttons
            document.getElementById('copy-right-btn').addEventListener('click', copySelectedToRight);
            document.getElementById('copy-left-btn').addEventListener('click', copySelectedToLeft);

            // Drag-and-drop for file grids
            const leftFiles = document.getElementById('left-files');
            const rightFiles = document.getElementById('right-files');

            leftFiles.addEventListener('dragover', (e) => handleDragOver(e, 'left'));
            leftFiles.addEventListener('drop', (e) => handleDrop(e, 'left'));
            leftFiles.addEventListener('dragleave', (e) => handleDragLeave(e, 'left'));

            rightFiles.addEventListener('dragover', (e) => handleDragOver(e, 'right'));
            rightFiles.addEventListener('drop', (e) => handleDrop(e, 'right'));
            rightFiles.addEventListener('dragleave', (e) => handleDragLeave(e, 'right'));

            // Job panel toggles
            document.getElementById('job-panel-header').addEventListener('click', toggleJobPanel);
            document.getElementById('interrupted-jobs-header').addEventListener('click', toggleInterruptedJobsDropdown);
            document.getElementById('failed-jobs-header').addEventListener('click', toggleFailedJobsDropdown);

            // Modal buttons - Interrupted Jobs Modal
            document.getElementById('interrupted-jobs-skip-btn').addEventListener('click', closeInterruptedJobsModal);
            document.getElementById('interrupted-jobs-resume-all-btn').addEventListener('click', resumeAllInterruptedJobs);

            // Modal buttons - Rename Modal
            document.getElementById('rename-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') confirmRename();
            });
            document.getElementById('rename-cancel-btn').addEventListener('click', closeRenameModal);
            document.getElementById('rename-confirm-btn').addEventListener('click', confirmRename);

            // Modal buttons - Create Folder Modal
            document.getElementById('create-folder-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') confirmCreateFolder();
            });
            document.getElementById('create-folder-cancel-btn').addEventListener('click', closeCreateFolderModal);
            document.getElementById('create-folder-confirm-btn').addEventListener('click', confirmCreateFolder);

            // Modal buttons - Delete Confirm Modal
            document.getElementById('delete-cancel-btn').addEventListener('click', closeDeleteConfirmModal);
            document.getElementById('delete-confirm-btn').addEventListener('click', confirmDelete);

            // Modal buttons - Drag Drop Confirm Modal
            document.getElementById('drag-drop-cancel-btn').addEventListener('click', closeDragDropConfirmModal);
            document.getElementById('drag-drop-confirm-btn').addEventListener('click', confirmDragDrop);

            // Modal buttons - Upload Progress Modal
            document.getElementById('upload-cancel-btn').addEventListener('click', cancelUpload);

            // Modal buttons - Manage Remotes Modal
            document.getElementById('manage-remotes-close-btn').addEventListener('click', () => remoteManager.close());
            document.getElementById('add-remote-btn').addEventListener('click', () => remoteManager.showTemplateSelection());
            document.getElementById('template-close-btn').addEventListener('click', () => remoteManager.showRemotesList());
            document.getElementById('template-next-btn').addEventListener('click', () => remoteManager.showRemoteForm());
            document.getElementById('configure-close-btn').addEventListener('click', () => remoteManager.showRemotesList());
            document.getElementById('configure-back-btn').addEventListener('click', () => remoteManager.showTemplateSelection());
            document.getElementById('create-remote-btn').addEventListener('click', () => remoteManager.createRemote());

            // Event delegation - Template selection
            document.getElementById('templates-list-container').addEventListener('click', (e) => {
                const templateItem = e.target.closest('.template-item');
                if (templateItem) {
                    const templateName = templateItem.dataset.templateName;
                    remoteManager.selectTemplate(templateName);
                }
            });

            // Event delegation - Remote list actions
            document.getElementById('remotes-list-container').addEventListener('click', (e) => {
                // Check if clicking on action button
                const actionBtn = e.target.closest('.remote-action-btn');
                if (actionBtn) {
                    e.stopPropagation(); // Prevent row click
                    const action = actionBtn.dataset.action;
                    const remoteName = actionBtn.dataset.remoteName;

                    if (action === 'refresh-oauth') {
                        refreshOAuthToken(remoteName);
                    } else if (action === 'edit') {
                        remoteManager.editRemoteConfig(remoteName);
                    } else if (action === 'delete') {
                        remoteManager.deleteRemote(remoteName);
                    }
                    return;
                }

                // Check if clicking on remote row
                const remoteRow = e.target.closest('.remote-row');
                if (remoteRow) {
                    const remoteName = remoteRow.dataset.remoteName;
                    remoteManager.viewRemoteConfig(remoteName);
                }
            });

            // Event delegation - Remote row hover effects
            document.getElementById('remotes-list-container').addEventListener('mouseover', (e) => {
                const remoteRow = e.target.closest('.remote-row');
                if (remoteRow) {
                    remoteRow.style.backgroundColor = '#f0f8ff';
                }
            });
            document.getElementById('remotes-list-container').addEventListener('mouseout', (e) => {
                const remoteRow = e.target.closest('.remote-row');
                if (remoteRow) {
                    remoteRow.style.backgroundColor = 'white';
                }
            });

            // Modal buttons - View Remote Config Modal
            document.getElementById('view-remote-close-btn').addEventListener('click', () => remoteManager.closeViewRemoteConfigModal());
            document.getElementById('copy-remote-config-btn').addEventListener('click', () => remoteManager.copyRemoteConfigToClipboard());

            // Modal buttons - Edit Remote Config Modal
            document.getElementById('edit-remote-cancel-btn').addEventListener('click', () => remoteManager.closeEditRemoteConfigModal());
            document.getElementById('edit-remote-save-btn').addEventListener('click', () => remoteManager.saveRemoteConfig());

            // Expert Mode buttons
            document.getElementById('expert-auth-btn').addEventListener('click', authenticate);
            document.getElementById('expert-list-remotes-btn').addEventListener('click', listRemotes);
            document.getElementById('ls-path').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') listFiles();
            });
            document.getElementById('expert-list-files-btn').addEventListener('click', listFiles);
            document.getElementById('mkdir-path').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') makeDirectory();
            });
            document.getElementById('expert-mkdir-btn').addEventListener('click', makeDirectory);
            document.getElementById('delete-path').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') deletePath();
            });
            document.getElementById('expert-delete-btn').addEventListener('click', deletePath);

            // Expert Mode - Job Management
            document.getElementById('job-src').addEventListener('keypress', (e) => handleJobPathKeypress(e, 'src'));
            document.getElementById('job-dst').addEventListener('keypress', (e) => handleJobPathKeypress(e, 'dst'));
            document.getElementById('expert-copy-btn').addEventListener('click', startCopyJob);
            document.getElementById('expert-move-btn').addEventListener('click', startMoveJob);
            document.getElementById('expert-integrity-btn').addEventListener('click', checkIntegrity);
            document.getElementById('expert-sync-btn').addEventListener('click', syncJob);
            document.getElementById('job-id').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') getJobStatus();
            });
            document.getElementById('expert-job-status-btn').addEventListener('click', getJobStatus);
            document.getElementById('expert-watch-progress-btn').addEventListener('click', watchJobProgress);
            document.getElementById('expert-stop-watch-btn').addEventListener('click', stopWatchingProgress);
            document.getElementById('expert-show-log-btn').addEventListener('click', showJobLog);
            document.getElementById('expert-resume-btn').addEventListener('click', resumeJobById);
            document.getElementById('expert-stop-job-btn').addEventListener('click', stopJob);
            document.getElementById('expert-list-all-btn').addEventListener('click', listAllJobs);
            document.getElementById('expert-list-running-btn').addEventListener('click', listRunningJobs);
            document.getElementById('expert-list-aborted-btn').addEventListener('click', listAbortedJobs);
            document.getElementById('expert-clear-stopped-btn').addEventListener('click', clearStoppedJobs);

            // Context Menu - Event delegation
            document.getElementById('context-menu').addEventListener('click', (e) => {
                const item = e.target.closest('.context-menu-item');
                if (!item) return;

                // Handle action items (create folder, rename, delete)
                const action = item.getAttribute('data-action');
                if (action) {
                    contextMenuAction(action);
                    return;
                }

                // Handle sort items
                const sortBy = item.getAttribute('data-sort');
                if (sortBy) {
                    const asc = item.getAttribute('data-asc') === 'true';
                    contextMenuSortBy(sortBy, asc);
                }
            });

            // Dynamic Job Buttons - Event delegation for active jobs
            document.getElementById('job-list').addEventListener('click', (e) => {
                const button = e.target.closest('.job-icon-btn');
                if (!button) return;

                const action = button.getAttribute('data-action');
                const jobId = parseInt(button.getAttribute('data-job-id'));

                if (action === 'cancel-job') {
                    cancelJob(jobId);
                }
            });

            // Dynamic Job Buttons - Event delegation for interrupted jobs
            document.getElementById('interrupted-jobs-list').addEventListener('click', (e) => {
                const button = e.target.closest('.job-icon-btn');
                if (!button) return;

                const action = button.getAttribute('data-action');
                const jobId = parseInt(button.getAttribute('data-job-id'));

                if (action === 'resume-interrupted') {
                    resumeInterruptedJobFromDropdown(jobId);
                } else if (action === 'cancel-interrupted') {
                    cancelInterruptedJob(jobId);
                }
            });

            // Dynamic Job Buttons - Event delegation for failed jobs
            document.getElementById('failed-jobs-list').addEventListener('click', (e) => {
                const button = e.target.closest('.job-icon-btn');
                if (!button) return;

                const action = button.getAttribute('data-action');
                const jobId = parseInt(button.getAttribute('data-job-id'));

                if (action === 'resume-failed') {
                    resumeFailedJobFromDropdown(jobId);
                } else if (action === 'cancel-failed') {
                    cancelFailedJob(jobId);
                }
            });
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize modal manager
            initModalManager();

            // Setup event listeners
            setupEventListeners();

            // Try to load token from URL
            const urlParams = new URLSearchParams(window.location.search);
            const tokenFromUrl = urlParams.get('token');
            if (tokenFromUrl) {
                authToken = tokenFromUrl;
                setAuthToken(tokenFromUrl);  // Sync with api.js
                document.getElementById('token').value = tokenFromUrl;
                // Set cookie
                document.cookie = `motus_token=${tokenFromUrl}; path=/; max-age=31536000`;
            } else {
                // Try to load from cookie
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    const [name, value] = cookie.trim().split('=');
                    if (name === 'motus_token') {
                        authToken = value;
                        setAuthToken(value);  // Sync with api.js
                        document.getElementById('token').value = value;
                        break;
                    }
                }
            }

            // Load config to get default mode and upload size limit
            try {
                const config = await apiCall('/api/config');
                currentMode = config.default_mode || 'easy';
                maxUploadSize = config.max_upload_size || 0;
                console.log('Max upload size:', maxUploadSize === 0 ? 'unlimited' : config.max_upload_size_formatted);
                setMode(currentMode);
            } catch (e) {
                console.error('Failed to load config:', e);
                setMode('easy');
            }

            // Load user preferences from backend
            await loadPreferences();

            // Load remotes for easy mode
            if (currentMode === 'easy') {
                await loadRemotes();
                // If using Local Filesystem, start in home directory
                if (leftPaneState.remote === '') {
                    leftPaneState.path = '~/';
                    document.getElementById('left-path').value = '~/';
                }
                if (rightPaneState.remote === '') {
                    rightPaneState.path = '~/';
                    document.getElementById('right-path').value = '~/';
                }
                await refreshPane('left');
                await refreshPane('right');
                startJobUpdates();
                startInterruptedJobsUpdates();
                startFailedJobsUpdates();
            }

            // Check for interrupted jobs modal (only on startup)
            checkInterruptedJobs();

            // Hide context menu and view dropdown on click outside
            document.addEventListener('click', () => {
                document.getElementById('context-menu').style.display = 'none';
                document.getElementById('view-dropdown').classList.add('hidden');
            });

            // Add context menu to empty container backgrounds
            ['left', 'right'].forEach(pane => {
                const container = document.getElementById(`${pane}-files`);
                container.addEventListener('contextmenu', (e) => {
                    // Only show menu if clicking on container itself or table, not on child file elements
                    if (e.target === container || e.target.tagName === 'TABLE') {
                        e.preventDefault();
                        const state = pane === 'left' ? leftPaneState : rightPaneState;
                        // Clear selection when right-clicking on empty space
                        if (state.selectedIndexes.length > 0) {
                            state.selectedIndexes = [];
                            renderFiles(pane);
                        }
                        showContextMenu(e, pane);
                    }
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Check if any modal is open
                const renameModal = document.getElementById('rename-modal');
                const deleteModal = document.getElementById('delete-confirm-modal');
                const createFolderModal = document.getElementById('create-folder-modal');
                const dragDropModal = document.getElementById('drag-drop-confirm-modal');
                const editRemoteModal = document.getElementById('edit-remote-config-modal');
                const viewRemoteModal = document.getElementById('view-remote-config-modal');

                // Handle Escape key
                if (e.key === 'Escape') {
                    // Close modals
                    if (renameModal.style.display === 'flex') {
                        closeRenameModal();
                        return;
                    }
                    if (deleteModal.style.display === 'flex') {
                        closeDeleteConfirmModal();
                        return;
                    }
                    if (createFolderModal.style.display === 'flex') {
                        closeCreateFolderModal();
                        return;
                    }
                    if (dragDropModal.style.display === 'flex') {
                        closeDragDropConfirmModal();
                        return;
                    }
                    if (editRemoteModal.style.display === 'flex') {
                        e.stopImmediatePropagation(); // Prevent other handlers from running
                        closeEditRemoteConfigModal();
                        return;
                    }
                    if (viewRemoteModal.style.display === 'flex') {
                        e.stopImmediatePropagation(); // Prevent other handlers from running
                        closeViewRemoteConfigModal();
                        return;
                    }
                    // Close menus
                    document.getElementById('context-menu').style.display = 'none';
                    document.getElementById('view-dropdown').classList.add('hidden');
                    return;
                }

                // Handle Enter key for modals
                if (e.key === 'Enter') {
                    if (renameModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmRename();
                        return;
                    }
                    if (deleteModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmDelete();
                        return;
                    }
                    if (createFolderModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmCreateFolder();
                        return;
                    }
                    if (dragDropModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmDragDrop();
                        return;
                    }
                }

                // Ignore other shortcuts when typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // F2 - Rename selected file/folder
                if (e.key === 'F2') {
                    e.preventDefault();
                    const state = lastFocusedPane === 'left' ? leftPaneState : rightPaneState;
                    if (state.selectedIndexes.length === 1) {
                        const file = state.files[state.selectedIndexes[0]];
                        contextMenuState.pane = lastFocusedPane;
                        contextMenuState.items = [file];
                        showRenameModal(file.Name);
                    }
                    return;
                }

                // Delete - Delete selected files/folders
                if (e.key === 'Delete') {
                    e.preventDefault();
                    const state = lastFocusedPane === 'left' ? leftPaneState : rightPaneState;
                    if (state.selectedIndexes.length > 0) {
                        contextMenuState.pane = lastFocusedPane;
                        contextMenuState.items = state.selectedIndexes.map(i => state.files[i]);
                        showDeleteConfirmModal();
                    }
                    return;
                }
            });

            // Click whitespace to deselect and track focused pane
            document.getElementById('left-files').addEventListener('click', (e) => {
                lastFocusedPane = 'left';
                if (e.target.id === 'left-files' || e.target.classList.contains('file-grid') || e.target.classList.contains('file-list')) {
                    leftPaneState.selectedIndexes = [];
                    renderFiles('left');
                }
            });
            document.getElementById('right-files').addEventListener('click', (e) => {
                lastFocusedPane = 'right';
                if (e.target.id === 'right-files' || e.target.classList.contains('file-grid') || e.target.classList.contains('file-list')) {
                    rightPaneState.selectedIndexes = [];
                    renderFiles('right');
                }
            });
        });

        // View menu toggle
        function toggleViewMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('view-dropdown');
            menu.classList.toggle('hidden');
            updateViewMenuItems();
        }

        function updateViewMenuItems() {
            // Update view mode option to show the OPPOSITE of current mode
            const modeIcon = document.getElementById('view-mode-icon');
            const modeText = document.getElementById('view-mode-text');
            if (viewMode === 'grid') {
                modeIcon.textContent = '‚ò∞';
                modeText.textContent = 'List layout';
            } else {
                modeIcon.textContent = '‚äû';
                modeText.textContent = 'Grid layout';
            }

            // Update hidden files text based on current state
            const hiddenText = document.getElementById('hidden-files-text');
            hiddenText.textContent = showHiddenFiles ? "Don't show hidden files" : "Show hidden files";
        }

        function switchViewMode() {
            viewMode = viewMode === 'grid' ? 'list' : 'grid';
            document.getElementById('view-dropdown').classList.add('hidden');

            // Save preference to backend
            savePreferences();

            // Re-render both panes
            renderFiles('left');
            renderFiles('right');
        }

        function toggleHiddenFilesOption() {
            showHiddenFiles = !showHiddenFiles;
            document.getElementById('view-dropdown').classList.add('hidden');

            // Save preference to backend
            savePreferences();

            // Re-render both panes
            renderFiles('left');
            renderFiles('right');
        }

        // Preferences wrapper functions (now using imported module)
        async function savePreferences() {
            await savePrefs(apiCall, {
                view_mode: viewMode,
                show_hidden_files: showHiddenFiles
            });
        }

        async function loadPreferences() {
            const prefs = await loadPrefs(apiCall);
            if (prefs.view_mode) {
                viewMode = prefs.view_mode;
                state.ui.viewMode = prefs.view_mode;
            }
            if (prefs.show_hidden_files !== undefined) {
                showHiddenFiles = prefs.show_hidden_files;
                state.ui.showHiddenFiles = prefs.show_hidden_files;
            }
        }

        // Helper functions now imported from modules

        function setSortBy(pane, field) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            if (state.sortBy === field) {
                state.sortAsc = !state.sortAsc;
            } else {
                state.sortBy = field;
                state.sortAsc = true;
            }
            renderFiles(pane);
        }

        // Column resizing
        let resizingColumn = null;
        let startX = 0;
        let startWidth = 0;

        function startColumnResize(e, th) {
            e.preventDefault();
            e.stopPropagation();

            resizingColumn = th;
            startX = e.pageX;
            startWidth = th.offsetWidth;

            document.addEventListener('mousemove', doColumnResize);
            document.addEventListener('mouseup', stopColumnResize);
        }

        function doColumnResize(e) {
            if (!resizingColumn) return;

            const diff = e.pageX - startX;
            const newWidth = startWidth + diff;

            // Enforce minimum width
            const minWidth = parseInt(window.getComputedStyle(resizingColumn).minWidth) || 50;
            if (newWidth >= minWidth) {
                resizingColumn.style.width = newWidth + 'px';
            }
        }

        function stopColumnResize() {
            resizingColumn = null;
            document.removeEventListener('mousemove', doColumnResize);
            document.removeEventListener('mouseup', stopColumnResize);
        }

        // Formatting and API functions now imported from modules

        // ENTER key handlers
        function handlePathKeypress(event, pane) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const state = pane === 'left' ? leftPaneState : rightPaneState;
                const inputPath = document.getElementById(`${pane}-path`).value;

                // Check if path changed
                if (inputPath !== state.path) {
                    browsePath(pane);
                } else {
                    refreshPane(pane);
                }
            }
        }

        function handleJobPathKeypress(event, field) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const srcValue = document.getElementById('job-src').value.trim();
                const dstValue = document.getElementById('job-dst').value.trim();

                if (field === 'src') {
                    // If in source field
                    if (srcValue && !dstValue) {
                        // Move to destination field
                        document.getElementById('job-dst').focus();
                    } else if (srcValue && dstValue) {
                        // Both filled, start copy
                        startCopyJob();
                    }
                } else if (field === 'dst') {
                    // If in destination field
                    if (srcValue && dstValue) {
                        // Both filled, start copy
                        startCopyJob();
                    }
                }
            }
        }

        // Mode switching
        function toggleMode() {
            setMode(currentMode === 'easy' ? 'expert' : 'easy');
        }

        function setMode(mode) {
            currentMode = mode;
            if (mode === 'easy') {
                document.getElementById('easy-mode').classList.remove('hidden');
                document.getElementById('expert-mode').classList.add('hidden');
                document.getElementById('mode-button-text').textContent = 'Expert Mode';
                if (!jobUpdateInterval) {
                    loadRemotes();
                    refreshPane('left');
                    refreshPane('right');
                    startJobUpdates();
                    startInterruptedJobsUpdates();
                }
            } else {
                document.getElementById('easy-mode').classList.add('hidden');
                document.getElementById('expert-mode').classList.remove('hidden');
                document.getElementById('mode-button-text').textContent = 'Easy Mode';
                if (jobUpdateInterval) {
                    clearInterval(jobUpdateInterval);
                    jobUpdateInterval = null;
                }
                if (interruptedJobsInterval) {
                    clearInterval(interruptedJobsInterval);
                    interruptedJobsInterval = null;
                }
            }
        }

        // Load remotes
        async function loadRemotes() {
            try {
                const data = await apiCall('/api/remotes');
                const leftSelect = document.getElementById('left-remote');
                const rightSelect = document.getElementById('right-remote');

                // Clear existing options except first
                leftSelect.innerHTML = '<option value="">Local Filesystem</option>';
                rightSelect.innerHTML = '<option value="">Local Filesystem</option>';

                data.remotes.forEach(remote => {
                    leftSelect.innerHTML += `<option value="${remote.name}">${remote.name}</option>`;
                    rightSelect.innerHTML += `<option value="${remote.name}">${remote.name}</option>`;
                });
            } catch (error) {
                console.error('Failed to load remotes:', error);
            }
        }

        // Remote change handler
        let isReverting = false;

        async function onRemoteChange(pane) {
            // Prevent recursion during revert
            if (isReverting) {
                isReverting = false;
                return;
            }

            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const select = document.getElementById(`${pane}-remote`);
            const pathInput = document.getElementById(`${pane}-path`);
            const oldRemote = state.remote;
            const oldPath = state.path;
            const newRemote = select.value;

            // When switching to Local Filesystem, go to home
            const newPath = (newRemote === '') ? '~/' : '/';

            state.remote = newRemote;
            state.path = newPath;
            pathInput.value = newPath;

            try {
                await refreshPane(pane);
            } catch (error) {
                // Revert to old remote and path on error
                isReverting = true;
                state.remote = oldRemote;
                state.path = oldPath;
                select.value = oldRemote;
                pathInput.value = oldPath;

                alert(`Failed to access remote: ${error.message}`);
            }
        }

        // Browse path
        function browsePath(pane) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            let path = document.getElementById(`${pane}-path`).value;
            // Expand tilde
            path = expandTildePath(path);
            state.path = path;
            document.getElementById(`${pane}-path`).value = path;
            refreshPane(pane);
        }

        // Refresh pane
        async function refreshPane(pane, preserveSelection = false) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const fullPath = state.remote ? `${state.remote}:${state.path}` : state.path;

            // Save current selection if preserving
            const selectedFileNames = preserveSelection ?
                state.selectedIndexes.map(idx => state.files[idx]?.Name).filter(n => n) :
                [];

            console.log(`refreshPane(${pane}, preserveSelection=${preserveSelection}), saving ${selectedFileNames.length} selected files:`, selectedFileNames);

            try {
                const data = await apiCall('/api/files/ls', 'POST', { path: fullPath });
                state.files = data.files || [];

                if (preserveSelection && selectedFileNames.length > 0) {
                    // Restore selection by matching file names
                    state.selectedIndexes = [];
                    selectedFileNames.forEach(name => {
                        const idx = state.files.findIndex(f => f.Name === name);
                        if (idx !== -1) {
                            state.selectedIndexes.push(idx);
                            console.log(`Restored selection: ${name} at index ${idx}`);
                        } else {
                            console.log(`Could not restore selection: ${name} not found`);
                        }
                    });
                    console.log(`Selection preservation: restored ${state.selectedIndexes.length} of ${selectedFileNames.length} files`);
                } else {
                    state.selectedIndexes = [];
                }

                renderFiles(pane);
            } catch (error) {
                console.error(`Failed to refresh ${pane} pane:`, error);
                alert(`Error: ${error.message}`);
                throw error; // Re-throw so callers can handle it
            }
        }

        // Render files in grid or list view
        function renderFiles(pane) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const container = document.getElementById(`${pane}-files`);

            // Filter hidden files if needed
            let filesToShow = state.files;
            if (!showHiddenFiles) {
                filesToShow = state.files.filter(f => !f.Name.startsWith('.'));
            }

            // Add original index to each file before sorting
            const filesWithIndex = filesToShow.map((file, idx) => ({
                ...file,
                _originalIndex: state.files.indexOf(file)
            }));

            // Sort files
            const sortedFiles = sortFiles(filesWithIndex, state.sortBy, state.sortAsc);

            // Store visual order mapping for Shift+click range selection
            // Maps original index -> visual position
            state.visualOrder = {};
            sortedFiles.forEach((file, visualPos) => {
                state.visualOrder[file._originalIndex] = visualPos;
            });

            container.innerHTML = '';
            container.className = viewMode === 'grid' ? 'file-grid' : 'file-list';

            if (viewMode === 'grid') {
                renderGridView(pane, sortedFiles, container, state);
            } else {
                renderListView(pane, sortedFiles, container, state);
            }

            // Update arrow button states
            updateArrowButtons();
        }

        function renderGridView(pane, files, container, state) {
            // Add parent directory if not at root
            if (state.path !== '/') {
                const parentDiv = createFileElement({
                    Name: '..',
                    IsDir: true
                }, -1, pane);
                container.appendChild(parentDiv);
            }

            files.forEach((file) => {
                const fileDiv = createFileElement(file, file._originalIndex, pane);
                container.appendChild(fileDiv);
            });
        }

        function renderListView(pane, files, container, state) {
            const table = document.createElement('table');

            // Create table header with sortable columns
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            const headers = [
                { label: 'Name', field: 'name', className: 'col-name' },
                { label: 'Size', field: 'size', className: 'col-size' },
                { label: 'Date', field: 'date', className: 'col-date' }
            ];

            headers.forEach((h, idx) => {
                const th = document.createElement('th');
                th.className = h.className;
                th.textContent = h.label;
                if (state.sortBy === h.field) {
                    const indicator = document.createElement('span');
                    indicator.className = 'sort-indicator';
                    indicator.textContent = state.sortAsc ? '‚ñ≤' : '‚ñº';
                    th.appendChild(indicator);
                }
                th.onclick = (e) => {
                    // Don't sort if clicking on resize handle
                    if (!e.target.classList.contains('resize-handle')) {
                        setSortBy(pane, h.field);
                    }
                };

                // Add resize handle (except for last column)
                if (idx < headers.length - 1) {
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.addEventListener('mousedown', (e) => startColumnResize(e, th));
                    th.appendChild(resizeHandle);
                }

                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');

            // Add parent directory if not at root
            if (state.path !== '/') {
                const tr = createListRow({ Name: '..', IsDir: true }, -1, pane);
                tbody.appendChild(tr);
            }

            files.forEach((file) => {
                const tr = createListRow(file, file._originalIndex, pane);
                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            container.appendChild(table);
        }

        // Create file element
        function createFileElement(file, index, pane) {
            const div = document.createElement('div');
            div.className = 'file-item';
            
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            if (index >= 0 && state.selectedIndexes.includes(index)) {
                div.classList.add('selected');
            }
            
            const icon = file.IsDir ? 'üìÅ' : 'üìÑ';
            div.innerHTML = `
                <div class="file-icon">${icon}</div>
                <div class="file-name">${file.Name}</div>
            `;

            // Double-click to navigate
            div.addEventListener('dblclick', () => {
                if (file.Name === '..') {
                    navigateUp(pane);
                } else if (file.IsDir) {
                    navigateInto(pane, file.Name);
                }
            });
            
            // Single click for selection
            if (index >= 0) {
                div.addEventListener('click', (e) => {
                    handleFileClick(pane, index, e);
                });

                // Draggable - handle mousedown for immediate selection before drag
                div.draggable = true;
                div.addEventListener('mousedown', (e) => {
                    // Only handle left mouse button without modifier keys
                    // If Ctrl/Cmd/Shift are pressed, let the click handler deal with multi-selection
                    if (e.button === 0 && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
                        // Select file immediately if not already selected
                        // This ensures visual feedback before drag starts
                        if (!state.selectedIndexes.includes(index)) {
                            console.log(`mousedown: Auto-selecting file ${index} before drag`);

                            // Clear opposite pane selection
                            const oppositeState = pane === 'left' ? rightPaneState : leftPaneState;
                            const oppositePane = pane === 'left' ? 'right' : 'left';
                            if (oppositeState.selectedIndexes.length > 0) {
                                oppositeState.selectedIndexes = [];
                                const oppositeContainer = document.getElementById(oppositePane === 'left' ? 'left-files' : 'right-files');
                                oppositeContainer.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            }

                            // Update state
                            state.selectedIndexes = [index];
                            // Update DOM directly without re-rendering to avoid interrupting drag
                            const container = document.getElementById(pane === 'left' ? 'left-files' : 'right-files');
                            container.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            div.classList.add('selected');
                        }
                    }
                });
                div.addEventListener('dragstart', (e) => {
                    handleDragStart(e, pane, index);
                });

                // Right-click context menu
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!state.selectedIndexes.includes(index)) {
                        state.selectedIndexes = [index];
                        renderFiles(pane);
                    }
                    showContextMenu(e, pane);
                });
            } else {
                // For ".." parent directory, add context menu without selection
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Clear selection for ".." - it's not a selectable item
                    state.selectedIndexes = [];
                    renderFiles(pane);
                    showContextMenu(e, pane);
                });
            }
            
            return div;
        }

        // Create list row (for list view)
        function createListRow(file, index, pane) {
            const tr = document.createElement('tr');
            tr.className = 'file-row';

            const state = pane === 'left' ? leftPaneState : rightPaneState;
            if (index >= 0 && state.selectedIndexes.includes(index)) {
                tr.classList.add('selected');
            }

            const icon = file.IsDir ? 'üìÅ' : 'üìÑ';

            // Name column
            const nameCell = document.createElement('td');
            nameCell.className = 'file-name-col';
            nameCell.innerHTML = `
                <span class="file-icon-small">${icon}</span>
                <span>${file.Name}</span>
            `;
            tr.appendChild(nameCell);

            // Size column
            const sizeCell = document.createElement('td');
            sizeCell.className = 'file-size-col';
            sizeCell.textContent = file.IsDir ? '' : formatFileSize(file.Size);
            tr.appendChild(sizeCell);

            // Date column
            const dateCell = document.createElement('td');
            dateCell.className = 'file-date-col';
            dateCell.textContent = formatFileDate(file.ModTime);
            tr.appendChild(dateCell);

            // Double-click to navigate
            tr.addEventListener('dblclick', () => {
                if (file.Name === '..') {
                    navigateUp(pane);
                } else if (file.IsDir) {
                    navigateInto(pane, file.Name);
                }
            });

            // Single click for selection
            if (index >= 0) {
                tr.addEventListener('click', (e) => {
                    handleFileClick(pane, index, e);
                });

                // Draggable - handle mousedown for immediate selection before drag
                tr.draggable = true;
                tr.addEventListener('mousedown', (e) => {
                    // Only handle left mouse button without modifier keys
                    // If Ctrl/Cmd/Shift are pressed, let the click handler deal with multi-selection
                    if (e.button === 0 && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
                        // Select file immediately if not already selected
                        // This ensures visual feedback before drag starts
                        if (!state.selectedIndexes.includes(index)) {
                            console.log(`mousedown: Auto-selecting file ${index} before drag`);

                            // Clear opposite pane selection
                            const oppositeState = pane === 'left' ? rightPaneState : leftPaneState;
                            const oppositePane = pane === 'left' ? 'right' : 'left';
                            if (oppositeState.selectedIndexes.length > 0) {
                                oppositeState.selectedIndexes = [];
                                const oppositeContainer = document.getElementById(oppositePane === 'left' ? 'left-files' : 'right-files');
                                oppositeContainer.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            }

                            // Update state
                            state.selectedIndexes = [index];
                            // Update DOM directly without re-rendering to avoid interrupting drag
                            const container = document.getElementById(pane === 'left' ? 'left-files' : 'right-files');
                            container.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            tr.classList.add('selected');
                        }
                    }
                });
                tr.addEventListener('dragstart', (e) => {
                    handleDragStart(e, pane, index);
                });

                // Right-click context menu
                tr.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!state.selectedIndexes.includes(index)) {
                        state.selectedIndexes = [index];
                        renderFiles(pane);
                    }
                    showContextMenu(e, pane);
                });
            } else {
                // For ".." parent directory, add context menu without selection
                tr.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Clear selection for ".." - it's not a selectable item
                    state.selectedIndexes = [];
                    renderFiles(pane);
                    showContextMenu(e, pane);
                });
            }

            return tr;
        }

        // Navigate up
        async function navigateUp(pane) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            let newPath;

            // Handle tilde paths specially
            if (state.path.startsWith('~/')) {
                if (state.path === '~/' || state.path === '~') {
                    // Already at home, can't go up
                    return;
                }
                // Remove tilde prefix, process, then add it back
                const pathWithoutTilde = state.path.substring(2); // Remove '~/'
                const pathParts = pathWithoutTilde.split('/').filter(p => p);
                pathParts.pop();
                if (pathParts.length === 0) {
                    newPath = '~/';
                } else {
                    newPath = '~/' + pathParts.join('/');
                }
            } else {
                // Regular path handling
                const pathParts = state.path.split('/').filter(p => p);
                pathParts.pop();
                newPath = '/' + pathParts.join('/');
            }

            // Save old path in case navigation fails
            const oldPath = state.path;
            state.path = newPath;
            document.getElementById(`${pane}-path`).value = newPath;

            try {
                await refreshPane(pane);
            } catch (error) {
                // Revert to old path if navigation failed
                state.path = oldPath;
                document.getElementById(`${pane}-path`).value = oldPath;
            }
        }

        // Navigate into directory
        async function navigateInto(pane, dirname) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const oldPath = state.path;
            const newPath = state.path.endsWith('/') ? state.path + dirname : state.path + '/' + dirname;

            state.path = newPath;
            document.getElementById(`${pane}-path`).value = newPath;

            try {
                await refreshPane(pane);
            } catch (error) {
                // Revert to old path if navigation failed
                state.path = oldPath;
                document.getElementById(`${pane}-path`).value = oldPath;
            }
        }

        // File selection
        function handleFileClick(pane, index, event) {
            lastFocusedPane = pane;  // Track which pane was clicked
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const oppositeState = pane === 'left' ? rightPaneState : leftPaneState;
            const oppositePane = pane === 'left' ? 'right' : 'left';
            let selectionChanged = false;
            let oppositeChanged = false;

            // Clear selection on opposite pane
            if (oppositeState.selectedIndexes.length > 0) {
                oppositeState.selectedIndexes = [];
                oppositeChanged = true;
            }

            if (event.ctrlKey || event.metaKey) {
                // Toggle selection
                const idx = state.selectedIndexes.indexOf(index);
                if (idx >= 0) {
                    state.selectedIndexes.splice(idx, 1);
                } else {
                    state.selectedIndexes.push(index);
                }
                selectionChanged = true;
            } else if (event.shiftKey && state.selectedIndexes.length > 0) {
                // Range selection from last selected to current
                // Use visual order (sorted) not array order
                const lastIndex = state.selectedIndexes[state.selectedIndexes.length - 1];
                const lastVisual = state.visualOrder[lastIndex] ?? lastIndex;
                const currentVisual = state.visualOrder[index] ?? index;
                const visualStart = Math.min(lastVisual, currentVisual);
                const visualEnd = Math.max(lastVisual, currentVisual);

                // Convert visual positions back to original indexes
                state.selectedIndexes = [];
                Object.keys(state.visualOrder).forEach(origIndex => {
                    const visualPos = state.visualOrder[origIndex];
                    if (visualPos >= visualStart && visualPos <= visualEnd) {
                        state.selectedIndexes.push(parseInt(origIndex));
                    }
                });
                selectionChanged = true;
            } else {
                // Single selection - only change if different
                if (state.selectedIndexes.length !== 1 || state.selectedIndexes[0] !== index) {
                    state.selectedIndexes = [index];
                    selectionChanged = true;
                }
            }

            // Re-render panes if selection changed
            if (selectionChanged) {
                renderFiles(pane);
            }
            if (oppositeChanged) {
                renderFiles(oppositePane);
            }
            // Always update arrow buttons after any selection change
            updateArrowButtons();
        }

        // Drag and drop
        function handleDragStart(event, pane, index) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;

            console.log(`handleDragStart: pane=${pane}, index=${index}, selected=${JSON.stringify(state.selectedIndexes)}`);

            // Note: Selection already happened in mousedown handler
            // This ensures the file is visually selected before drag starts

            event.dataTransfer.effectAllowed = 'copy';
            event.dataTransfer.setData('text/plain', JSON.stringify({
                pane,
                indexes: state.selectedIndexes
            }));
        }

        function handleDragOver(event, targetPane) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            document.getElementById(`${targetPane}-files`).classList.add('drag-over');
        }

        function handleDragLeave(event, targetPane) {
            document.getElementById(`${targetPane}-files`).classList.remove('drag-over');
        }

        async function handleDrop(event, targetPane) {
            event.preventDefault();
            document.getElementById(`${targetPane}-files`).classList.remove('drag-over');

            // Check if this is external file drop (from desktop)
            const dragDataText = event.dataTransfer.getData('text/plain');
            const items = event.dataTransfer.items;
            const externalFiles = event.dataTransfer.files;

            if ((items || externalFiles) && externalFiles.length > 0 && !dragDataText) {
                // External file drop from desktop - check for folders
                if (items && items.length > 0) {
                    // Use DataTransferItem API to support folders (Chrome/Edge/Safari)
                    await handleExternalDropWithFolders(items, targetPane);
                } else {
                    // Fallback to simple file drop (Firefox)
                    await handleExternalFileDrop(externalFiles, targetPane);
                }
                return;
            }

            // Internal drag-drop between panes
            const data = JSON.parse(dragDataText);
            const sourcePane = data.pane;

            if (sourcePane === targetPane) {
                return; // Can't drop on same pane
            }

            const sourceState = sourcePane === 'left' ? leftPaneState : rightPaneState;
            const targetState = targetPane === 'left' ? leftPaneState : rightPaneState;

            // Build file list and paths for confirmation dialog
            const files = data.indexes.map(index => sourceState.files[index]);
            const fileNames = files.map(f => f.Name);

            // Build source and destination paths
            const sourcePath = sourceState.remote ?
                `${sourceState.remote}:${sourceState.path}` :
                sourceState.path;
            const destPath = targetState.remote ?
                `${targetState.remote}:${targetState.path}` :
                targetState.path;

            // Store the pending operation
            pendingDragDrop = {
                sourcePane,
                targetPane,
                sourceState,
                targetState,
                indexes: data.indexes,
                files
            };

            // Show confirmation dialog
            showDragDropConfirmModal(fileNames, sourcePath, destPath);
        }

        async function handleExternalDropWithFolders(items, targetPane) {
            const targetState = targetPane === 'left' ? leftPaneState : rightPaneState;

            console.log('Processing drop with folder support...');

            try {
                // Collect all files (including from folders recursively)
                const filesWithPaths = [];

                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : item.getAsEntry?.();
                        if (entry) {
                            await traverseFileTree(entry, '', filesWithPaths);
                        } else {
                            // Fallback for browsers without folder support
                            const file = item.getAsFile();
                            if (file) {
                                filesWithPaths.push({ file, path: file.name });
                            }
                        }
                    }
                }

                if (filesWithPaths.length === 0) {
                    alert('No files found to upload');
                    return;
                }

                console.log(`Found ${filesWithPaths.length} files (including in folders)`);

                // Check size limit
                const sizeCheck = checkUploadSizeLimit(filesWithPaths);
                if (!sizeCheck.valid) {
                    alert(sizeCheck.error);
                    return;
                }

                // Build destination path
                const destPath = targetState.remote ?
                    `${targetState.remote}:${targetState.path}` :
                    targetState.path;

                // Get file names for confirmation (show paths for nested files)
                const fileNames = filesWithPaths.map(f => f.path);

                // Show confirmation modal
                showDragDropConfirmModal(fileNames, 'Your Computer', destPath);

                // Store external file drop info
                pendingDragDrop = {
                    isExternal: true,
                    externalFiles: filesWithPaths,  // Array of {file, path}
                    targetPane,
                    targetState,
                    hasDirectories: true
                };

            } catch (error) {
                console.error('Error processing folder drop:', error);
                alert('Error processing dropped folders. Your browser may not support folder uploads.\n\nTry using Chrome, Edge, or Safari for folder support.');
            }
        }

        async function traverseFileTree(entry, path, filesWithPaths) {
            if (entry.isFile) {
                // It's a file, get the File object
                return new Promise((resolve, reject) => {
                    entry.file(
                        file => {
                            const fullPath = path + file.name;
                            filesWithPaths.push({ file, path: fullPath });
                            resolve();
                        },
                        error => {
                            console.error('Error reading file:', error);
                            resolve(); // Continue even if one file fails
                        }
                    );
                });
            } else if (entry.isDirectory) {
                // It's a directory, read its contents
                const dirReader = entry.createReader();
                return new Promise((resolve, reject) => {
                    const readEntries = () => {
                        dirReader.readEntries(
                            async entries => {
                                if (entries.length === 0) {
                                    resolve(); // No more entries
                                    return;
                                }
                                // Process all entries in this batch
                                for (const childEntry of entries) {
                                    await traverseFileTree(childEntry, path + entry.name + '/', filesWithPaths);
                                }
                                // Continue reading (directories can have multiple batches)
                                readEntries();
                            },
                            error => {
                                console.error('Error reading directory:', error);
                                resolve(); // Continue even if one directory fails
                            }
                        );
                    };
                    readEntries();
                });
            }
        }

        async function handleExternalFileDrop(files, targetPane) {
            const targetState = targetPane === 'left' ? leftPaneState : rightPaneState;

            // Convert FileList to Array immediately (FileList becomes invalid after event)
            const filesArray = Array.from(files);

            // Check size limit
            const sizeCheck = checkUploadSizeLimit(filesArray);
            if (!sizeCheck.valid) {
                alert(sizeCheck.error);
                return;
            }

            // Build destination path
            const destPath = targetState.remote ?
                `${targetState.remote}:${targetState.path}` :
                targetState.path;

            // Get file names for confirmation
            const fileNames = filesArray.map(f => f.name);

            // Show confirmation modal
            showDragDropConfirmModal(fileNames, 'Your Computer', destPath);

            // Store external file drop info with proper array
            pendingDragDrop = {
                isExternal: true,
                externalFiles: filesArray,  // Store as array, not FileList
                targetPane,
                targetState
            };
        }

        function showDragDropConfirmModal(fileNames, sourcePath, destPath) {
            // Populate file list
            const fileListHtml = fileNames.map(name => `‚Ä¢ ${name}`).join('<br>');
            document.getElementById('drag-drop-file-list').innerHTML = fileListHtml;

            // Show source and destination
            document.getElementById('drag-drop-source').textContent = sourcePath;
            document.getElementById('drag-drop-destination').textContent = destPath;

            // Show modal
            document.getElementById('drag-drop-confirm-modal').style.display = 'flex';
        }

        function closeDragDropConfirmModal() {
            document.getElementById('drag-drop-confirm-modal').style.display = 'none';
            pendingDragDrop = null;
        }

        function showUploadProgressModal(fileCount) {
            // Reset progress
            uploadAbortController = new AbortController();
            uploadStartTime = Date.now();

            document.getElementById('upload-progress-message').textContent =
                `Uploading ${fileCount} file${fileCount !== 1 ? 's' : ''}...`;
            document.getElementById('upload-progress-bar').style.width = '0%';
            document.getElementById('upload-progress-percent').textContent = '0%';
            document.getElementById('upload-progress-details').textContent = '';
            document.getElementById('upload-cancel-btn').disabled = false;

            document.getElementById('upload-progress-modal').style.display = 'flex';
        }

        function updateUploadProgress(loaded, total) {
            const percent = Math.round((loaded / total) * 100);
            const elapsedSeconds = (Date.now() - uploadStartTime) / 1000;
            const speedMBps = (loaded / 1024 / 1024) / elapsedSeconds;

            document.getElementById('upload-progress-bar').style.width = percent + '%';
            document.getElementById('upload-progress-percent').textContent = percent + '%';

            const loadedMB = (loaded / 1024 / 1024).toFixed(1);
            const totalMB = (total / 1024 / 1024).toFixed(1);
            document.getElementById('upload-progress-details').textContent =
                `${loadedMB} MB / ${totalMB} MB (${speedMBps.toFixed(1)} MB/s)`;
        }

        function closeUploadProgressModal() {
            document.getElementById('upload-progress-modal').style.display = 'none';
            uploadAbortController = null;
            uploadStartTime = null;
        }

        function cancelUpload() {
            if (uploadAbortController) {
                uploadAbortController.abort();
                document.getElementById('upload-cancel-btn').disabled = true;
                document.getElementById('upload-progress-message').textContent = 'Canceling upload...';
            }
        }

        function formatSize(bytes) {
            if (bytes === 0) return 'unlimited';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let size = bytes;
            let unitIndex = 0;
            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }
            return `${size.toFixed(1)} ${units[unitIndex]}`;
        }

        function checkUploadSizeLimit(files) {
            // Skip check if no limit configured (0 = unlimited)
            if (maxUploadSize === 0) {
                return { valid: true, totalSize: 0 };
            }

            // Calculate total size
            let totalSize = 0;
            for (const item of files) {
                // Handle both File objects and {file, path} objects
                const file = item.file || item;
                totalSize += file.size;
            }

            // Check if exceeds limit
            if (totalSize > maxUploadSize) {
                return {
                    valid: false,
                    totalSize,
                    error: `Total upload size (${formatSize(totalSize)}) exceeds maximum allowed (${formatSize(maxUploadSize)})`
                };
            }

            return { valid: true, totalSize };
        }

        async function confirmDragDrop() {
            if (!pendingDragDrop) return;

            // Save reference before closing modal (closeDragDropConfirmModal sets pendingDragDrop to null)
            const operation = pendingDragDrop;

            // Close modal
            closeDragDropConfirmModal();

            // Handle external file drop
            if (operation.isExternal) {
                // Restore pendingDragDrop for handleExternalFileUploadAndCopy
                pendingDragDrop = operation;
                await handleExternalFileUploadAndCopy();
                pendingDragDrop = null;
                return;
            }

            // Handle internal drag-drop
            const { sourceState, targetState, targetPane, indexes } = operation;

            // Start copy jobs for each selected file
            for (const index of indexes) {
                const file = sourceState.files[index];
                const srcPath = sourceState.remote ?
                    `${sourceState.remote}:${buildPath(sourceState.path, file.Name)}` :
                    buildPath(sourceState.path, file.Name);
                // Destination with trailing slash (rsync semantics: copy into directory)
                const dstPath = targetState.remote ?
                    `${targetState.remote}:${targetState.path}/` :
                    `${targetState.path}/`;

                try {
                    await apiCall('/api/jobs/copy', 'POST', {
                        src_path: srcPath,
                        dst_path: dstPath,
                        copy_links: false
                    });
                } catch (error) {
                    console.error('Copy failed:', error);
                    alert(`Failed to copy ${file.Name}: ${error.message}`);
                }
            }

            // Refresh target pane and update jobs
            refreshPane(targetPane);
            updateJobs();
        }

        async function handleExternalFileUploadAndCopy() {
            const { externalFiles, targetState, targetPane, hasDirectories } = pendingDragDrop;

            console.log('Starting external file upload. Files:', externalFiles);
            console.log('Target state:', targetState);
            console.log('Number of files:', externalFiles.length);
            console.log('Has directories:', hasDirectories);

            // Check if destination is local (no remote) - if so, upload directly
            const isLocalDestination = !targetState.remote;

            if (isLocalDestination) {
                console.log('Uploading directly to local filesystem:', targetState.path);
                // Direct upload to local filesystem (no cache needed)
                await handleDirectLocalUpload(externalFiles, targetState, targetPane, hasDirectories);
                return;
            }

            // Remote destination - use cache approach
            console.log('Uploading to remote via cache:', targetState.remote);
            // Generate unique job ID
            const jobId = 'upload-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            console.log('Generated job ID:', jobId);

            // Show progress modal
            showUploadProgressModal(externalFiles.length);

            try {
                // Step 1: Upload files to cache
                const formData = new FormData();

                // Handle both formats: array of Files or array of {file, path} objects
                if (hasDirectories) {
                    // filesWithPaths format: [{file: File, path: "folder/file.txt"}, ...]
                    for (const item of externalFiles) {
                        formData.append('files[]', item.file);
                        formData.append('paths[]', item.path);  // Relative path including folders
                    }
                } else {
                    // Simple File array format
                    for (const file of externalFiles) {
                        formData.append('files[]', file);
                    }
                }

                formData.append('job_id', jobId);
                formData.append('has_directories', hasDirectories ? 'true' : 'false');

                // Destination path
                const destPath = `${targetState.remote}:${targetState.path}`;
                formData.append('destination', destPath);

                // Upload files with progress tracking using XMLHttpRequest
                const uploadData = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();

                    // Track upload progress
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            updateUploadProgress(e.loaded, e.total);
                        }
                    });

                    xhr.addEventListener('load', () => {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                resolve(JSON.parse(xhr.responseText));
                            } catch (e) {
                                reject(new Error('Invalid response from server'));
                            }
                        } else {
                            reject(new Error('Upload failed: ' + xhr.statusText));
                        }
                    });

                    xhr.addEventListener('error', () => {
                        reject(new Error('Network error during upload'));
                    });

                    xhr.addEventListener('abort', () => {
                        reject(new Error('Upload canceled'));
                    });

                    xhr.open('POST', '/api/upload');
                    xhr.setRequestHeader('Authorization', `Bearer ${localStorage.getItem('token')}`);

                    // Wire up abort controller
                    if (uploadAbortController) {
                        uploadAbortController.signal.addEventListener('abort', () => {
                            xhr.abort();
                        });
                    }

                    xhr.send(formData);
                });

                console.log('Files uploaded to cache:', uploadData);

                // Update progress message
                document.getElementById('upload-progress-message').textContent = 'Upload complete! Starting transfer to destination...';
                document.getElementById('upload-cancel-btn').disabled = true;

                // Step 2: Copy from cache to destination
                const cachePath = uploadData.cache_path;
                const dstPath = `${targetState.remote}:${targetState.path}/`;

                const copyResult = await apiCall('/api/jobs/copy', 'POST', {
                    src_path: cachePath + '/',  // Copy all files from cache directory
                    dst_path: dstPath,
                    copy_links: false
                });

                console.log('Copy job started:', copyResult);

                // Step 3: Schedule cache cleanup after job completes
                // This will be monitored by watching the job status
                monitorUploadJobForCleanup(copyResult.job_id, jobId);

                // Close progress modal
                setTimeout(() => {
                    closeUploadProgressModal();
                }, 1000);  // Keep modal visible for 1 second to show completion

                // Refresh target pane and update jobs
                refreshPane(targetPane);
                updateJobs();

            } catch (error) {
                console.error('External file upload/copy failed:', error);
                closeUploadProgressModal();
                alert(`Failed to upload files: ${error.message}`);

                // Clean up cache on error
                try {
                    await fetch(`/api/upload/cleanup/${jobId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        }
                    });
                } catch (cleanupError) {
                    console.error('Cache cleanup failed:', cleanupError);
                }
            }
        }

        async function handleDirectLocalUpload(files, targetState, targetPane, hasDirectories) {
            // Upload directly to local filesystem
            console.log('handleDirectLocalUpload called with', files.length, 'files');
            console.log('Destination:', targetState.path);
            console.log('Has directories:', hasDirectories);

            // Show progress modal
            showUploadProgressModal(files.length);

            try {
                const formData = new FormData();

                // Handle both formats: array of Files or array of {file, path} objects
                if (hasDirectories) {
                    // filesWithPaths format: [{file: File, path: "folder/file.txt"}, ...]
                    for (const item of files) {
                        console.log('Adding file to FormData:', item.path, 'size:', item.file.size);
                        formData.append('files[]', item.file);
                        formData.append('paths[]', item.path);  // Relative path including folders
                    }
                } else {
                    // Simple File array format
                    for (const file of files) {
                        console.log('Adding file to FormData:', file.name, 'size:', file.size);
                        formData.append('files[]', file);
                    }
                }

                // Use a placeholder job_id (not actually used for direct upload)
                formData.append('job_id', 'direct-' + Date.now());
                formData.append('destination', targetState.path);
                formData.append('direct_upload', 'true');  // Flag for direct upload
                formData.append('has_directories', hasDirectories ? 'true' : 'false');

                console.log('Sending upload request...');

                // Upload with progress tracking using XMLHttpRequest
                const uploadData = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();

                    // Track upload progress
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            updateUploadProgress(e.loaded, e.total);
                        }
                    });

                    xhr.addEventListener('load', () => {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            try {
                                resolve(JSON.parse(xhr.responseText));
                            } catch (e) {
                                reject(new Error('Invalid response from server'));
                            }
                        } else {
                            reject(new Error('Upload failed: ' + xhr.statusText));
                        }
                    });

                    xhr.addEventListener('error', () => {
                        reject(new Error('Network error during upload'));
                    });

                    xhr.addEventListener('abort', () => {
                        reject(new Error('Upload canceled'));
                    });

                    xhr.open('POST', '/api/upload');
                    xhr.setRequestHeader('Authorization', `Bearer ${localStorage.getItem('token')}`);

                    // Wire up abort controller
                    if (uploadAbortController) {
                        uploadAbortController.signal.addEventListener('abort', () => {
                            xhr.abort();
                        });
                    }

                    xhr.send(formData);
                });

                console.log('Files uploaded directly to local filesystem:', uploadData);

                // Update progress message
                document.getElementById('upload-progress-message').textContent = 'Upload complete!';
                document.getElementById('upload-cancel-btn').disabled = true;

                // Close progress modal after a short delay
                setTimeout(() => {
                    closeUploadProgressModal();
                }, 1000);

                // Refresh target pane
                refreshPane(targetPane);

            } catch (error) {
                console.error('Direct local upload failed:', error);
                closeUploadProgressModal();
                alert(`Failed to upload files: ${error.message}`);
            }
        }

        async function monitorUploadJobForCleanup(copyJobId, uploadJobId) {
            // Poll job status until completion
            const checkInterval = setInterval(async () => {
                try {
                    const job = await apiCall(`/api/jobs/${copyJobId}`);

                    if (job.status === 'completed' || job.status === 'failed') {
                        clearInterval(checkInterval);

                        // Clean up cache
                        await fetch(`/api/upload/cleanup/${uploadJobId}`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('token')}`
                            }
                        });

                        console.log(`Cleaned up cache for upload job ${uploadJobId}`);
                    }
                } catch (error) {
                    console.error('Error monitoring upload job:', error);
                    clearInterval(checkInterval);
                }
            }, 5000);  // Check every 5 seconds
        }

        // Context menu
        function showContextMenu(event, pane) {
            lastFocusedPane = pane;  // Track which pane has context menu
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            contextMenuState.pane = pane;
            contextMenuState.items = state.selectedIndexes.map(i => state.files[i]);

            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';

            // Get menu items
            const menuItems = menu.querySelectorAll('.context-menu-item');
            const createFolderItem = menuItems[0];  // üìÅ Create Folder
            const renameItem = menuItems[1];  // ‚úèÔ∏è Rename
            const deleteItem = menuItems[2];  // üóëÔ∏è Delete

            // Show/hide items based on selection
            const hasSelection = state.selectedIndexes.length > 0;
            const isSingleSelection = state.selectedIndexes.length === 1;

            // Create Folder: always available
            createFolderItem.style.display = 'block';

            // Rename: only for single selection
            if (isSingleSelection) {
                renameItem.style.display = 'block';
            } else {
                renameItem.style.display = 'none';
            }

            // Delete: only when something is selected
            if (hasSelection) {
                deleteItem.style.display = 'block';
            } else {
                deleteItem.style.display = 'none';
            }
        }

        function contextMenuAction(action) {
            document.getElementById('context-menu').style.display = 'none';

            if (action === 'rename' && contextMenuState.items.length === 1) {
                showRenameModal(contextMenuState.items[0].Name);
            } else if (action === 'delete') {
                showDeleteConfirmModal();
            } else if (action === 'newfolder') {
                createFolder(contextMenuState.pane);
            }
        }

        function contextMenuSortBy(field, ascending) {
            document.getElementById('context-menu').style.display = 'none';

            const pane = contextMenuState.pane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            state.sortBy = field;
            state.sortAsc = ascending;
            renderFiles(pane);
        }

        // Rename modal
        function showRenameModal(currentName) {
            const input = document.getElementById('rename-input');
            input.value = currentName;

            ModalManager.open('rename-modal', {
                onEscape: closeRenameModal,
                onEnter: confirmRename
            });

            // Select text after modal opens for easy editing
            setTimeout(() => {
                input.select();
            }, 150);
        }

        function closeRenameModal() {
            ModalManager.close('rename-modal');
        }

        async function confirmRename() {
            const newName = document.getElementById('rename-input').value.trim();
            if (!newName) {
                alert('Please enter a name');
                return;
            }

            const pane = contextMenuState.pane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const file = contextMenuState.items[0];

            // Skip no-op rename (same name)
            if (newName === file.Name) {
                closeRenameModal();
                return;
            }

            // Check if destination already exists
            const existingFile = state.files.find(f => f.Name === newName);
            if (existingFile) {
                alert(`A file or folder named "${newName}" already exists in this directory`);
                return;
            }

            const oldPath = state.remote ?
                `${state.remote}:${buildPath(state.path, file.Name)}` :
                buildPath(state.path, file.Name);
            const newPath = state.remote ?
                `${state.remote}:${buildPath(state.path, newName)}` :
                buildPath(state.path, newName);

            try {
                // Use move operation for rename
                await apiCall('/api/jobs/move', 'POST', {
                    src_path: oldPath,
                    dst_path: newPath
                });
                closeRenameModal();
                refreshPane(pane);
            } catch (error) {
                alert(`Rename failed: ${error.message}`);
            }
        }

        // Delete confirmation
        function showDeleteConfirmModal() {
            const count = contextMenuState.items.length;
            document.getElementById('delete-confirm-message').textContent =
                `Are you sure you want to delete ${count} item(s)?`;

            ModalManager.open('delete-confirm-modal', {
                onEscape: closeDeleteConfirmModal,
                onEnter: confirmDelete
            });
        }

        function closeDeleteConfirmModal() {
            ModalManager.close('delete-confirm-modal');
        }

        async function confirmDelete() {
            const pane = contextMenuState.pane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;

            // Close modal immediately for better UX
            closeDeleteConfirmModal();

            // Perform deletes in background
            for (const file of contextMenuState.items) {
                const path = state.remote ?
                    `${state.remote}:${buildPath(state.path, file.Name)}` :
                    buildPath(state.path, file.Name);

                try {
                    await apiCall('/api/files/delete', 'POST', { path });
                } catch (error) {
                    alert(`Failed to delete ${file.Name}: ${error.message}`);
                }
            }

            // Refresh after all deletes complete
            refreshPane(pane, true);
        }

        // Create folder
        function createFolder(pane) {
            createFolderPane = pane;
            const input = document.getElementById('create-folder-input');
            input.value = '';

            ModalManager.open('create-folder-modal', {
                onEscape: closeCreateFolderModal,
                onEnter: confirmCreateFolder
            });
        }

        function closeCreateFolderModal() {
            ModalManager.close('create-folder-modal');
        }

        async function confirmCreateFolder() {
            let name = document.getElementById('create-folder-input').value.trim();
            if (!name) {
                alert('Please enter a folder name');
                return;
            }

            const pane = createFolderPane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;

            // Support relative paths - resolve against current directory
            const resolvedName = resolveRelativePath(state.path, name);

            const path = state.remote ?
                `${state.remote}:${resolvedName}` :
                resolvedName;

            try {
                await apiCall('/api/files/mkdir', 'POST', { path: expandTildePath(path) });
                closeCreateFolderModal();
                refreshPane(pane);
            } catch (error) {
                alert(`Failed to create folder: ${error.message}`);
            }
        }

        // Remote Manager functions are now handled by the RemoteManager module

        // OAuth Management
        let currentOAuthRemote = null;

        async function refreshOAuthToken(remoteName) {
            try {
                currentOAuthRemote = remoteName;

                // Call API to start OAuth refresh
                const response = await apiCall(`/api/remotes/${remoteName}/oauth/refresh`, 'POST');

                if (response.status === 'needs_token') {
                    // Populate modal with authorize command
                    document.getElementById('oauth-authorize-command').textContent = response.authorize_command;
                    document.getElementById('oauth-token-input').value = '';
                    document.getElementById('oauth-status-message').style.display = 'none';
                    document.getElementById('oauth-submit-btn').disabled = false;

                    // Open modal using ModalManager
                    ModalManager.open('oauth-interactive-modal', {
                        onEscape: closeOAuthModal,
                        onEnter: submitOAuthToken,
                        onClose: () => {
                            // Cleanup when modal closes
                            currentOAuthRemote = null;
                        }
                    });
                } else if (response.status === 'complete') {
                    // Token refresh completed immediately (shouldn't normally happen, but handle it)
                    alert(`OAuth token successfully refreshed for "${remoteName}"`);
                    await loadRemotesList();
                    currentOAuthRemote = null;
                } else if (response.status === 'error') {
                    // Error occurred
                    alert(`Failed to refresh OAuth token: ${response.message || 'Unknown error'}`);
                    currentOAuthRemote = null;
                } else {
                    // Unexpected response
                    alert(`Unexpected response from server: ${response.status}`);
                    currentOAuthRemote = null;
                }
            } catch (error) {
                currentOAuthRemote = null;
                alert(`Failed to refresh OAuth token: ${error.message}`);
            }
        }

        async function submitOAuthToken() {
            if (!currentOAuthRemote) {
                alert('No OAuth session active');
                return;
            }

            const token = document.getElementById('oauth-token-input').value.trim();
            if (!token) {
                showOAuthStatus('Please paste the token before submitting', 'error');
                return;
            }

            // Disable submit button during submission
            const submitBtn = document.getElementById('oauth-submit-btn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submitting...';

            try {
                showOAuthStatus('Submitting token...', 'info');

                // Submit token to API
                const response = await apiCall(
                    `/api/remotes/${currentOAuthRemote}/oauth/submit-token`,
                    'POST',
                    { token: token }
                );

                if (response.status === 'complete') {
                    // Success!
                    showOAuthStatus('‚úì Token successfully submitted! OAuth refresh complete.', 'success');

                    // Wait a moment before closing
                    setTimeout(async () => {
                        closeOAuthModal();
                        await loadRemotesList();
                        // Success - no alert needed, just close and refresh
                    }, 1500);
                } else if (response.status === 'error') {
                    // Error
                    showOAuthStatus(`Error: ${response.message || 'Unknown error'}`, 'error');
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Token';
                } else {
                    // Unexpected status
                    showOAuthStatus(`Unexpected response: ${response.status}`, 'error');
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Token';
                }
            } catch (error) {
                showOAuthStatus(`Failed to submit token: ${error.message}`, 'error');
                submitBtn.disabled = false;
                submitBtn.textContent = 'Submit Token';
            }
        }

        function showOAuthStatus(message, type) {
            const statusDiv = document.getElementById('oauth-status-message');
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';

            // Set background color based on type
            if (type === 'success') {
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';
                statusDiv.style.border = '1px solid #c3e6cb';
            } else if (type === 'error') {
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                statusDiv.style.border = '1px solid #f5c6cb';
            } else {
                // info
                statusDiv.style.background = '#d1ecf1';
                statusDiv.style.color = '#0c5460';
                statusDiv.style.border = '1px solid #bee5eb';
            }
        }

        async function copyAuthorizeCommand() {
            const commandText = document.getElementById('oauth-authorize-command').textContent;

            try {
                await navigator.clipboard.writeText(commandText);

                // Show tooltip
                const tooltip = document.getElementById('oauth-copy-tooltip');
                tooltip.style.display = 'inline';

                // Hide after 1 second
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 1000);
            } catch (error) {
                console.error('Failed to copy to clipboard:', error);

                // Fallback for older browsers or when clipboard API fails
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = commandText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);

                    // Show tooltip even with fallback
                    const tooltip = document.getElementById('oauth-copy-tooltip');
                    tooltip.style.display = 'inline';
                    setTimeout(() => {
                        tooltip.style.display = 'none';
                    }, 1000);
                } catch (err) {
                    alert('Failed to copy to clipboard. Please copy manually.');
                }
            }
        }

        function closeOAuthModal() {
            // Clean up modal UI
            document.getElementById('oauth-token-input').value = '';
            document.getElementById('oauth-status-message').style.display = 'none';
            document.getElementById('oauth-submit-btn').disabled = false;
            document.getElementById('oauth-submit-btn').textContent = 'Submit Token';

            // Close via ModalManager (will trigger onClose handler which sets currentOAuthRemote = null)
            ModalManager.close('oauth-interactive-modal');
        }

        async function createRemote() {
            const template = manageRemotesState.selectedTemplate;

            // Handle custom remote creation
            if (template.name === '__custom__') {
                const configText = document.getElementById('custom-remote-config').value.trim();

                // Extract remote name from config
                const match = configText.match(/^\[(.+?)\]/m);
                if (!match) {
                    alert('Configuration must include a [remote_name] section header');
                    return;
                }
                const remoteName = match[1];

                try {
                    const createBtn = document.getElementById('create-remote-btn');
                    createBtn.disabled = true;
                    createBtn.textContent = 'Create';

                    // Use the raw config API to create the remote
                    await apiCall('/api/remotes/raw', 'POST', {
                        raw_config: configText
                    });

                    // Reload remotes list and dropdowns
                    await loadRemotesList();
                    await loadRemotes();

                    // Go back to step 1
                    showRemotesList();
                    manageRemotesState.selectedTemplate = null;
                    manageRemotesState.formValues = {};

                    // Check if the newly created remote needs OAuth and auto-trigger
                    await checkAndTriggerOAuthForNewRemote(remoteName);
                } catch (error) {
                    alert(`Failed to create remote: ${error.message}`);
                    const createBtn = document.getElementById('create-remote-btn');
                    createBtn.disabled = false;
                    createBtn.textContent = 'Create Remote';
                }
                return;
            }

            // Regular template-based remote creation
            const remoteName = document.getElementById('remote-name-input').value.trim();

            if (!remoteName) {
                alert('Please enter a remote name');
                return;
            }

            if (!/^[a-zA-Z0-9_-]+$/.test(remoteName)) {
                alert('Invalid remote name. Use only letters, numbers, underscores, and hyphens.');
                return;
            }

            // Collect field values
            const values = {};
            for (const field of template.fields) {
                const input = document.getElementById(`field-${field.key}`);
                if (!input || !input.value.trim()) {
                    alert(`Please fill in all fields: ${field.label}`);
                    return;
                }
                values[field.label] = input.value.trim();
            }

            try {
                const createBtn = document.getElementById('create-remote-btn');
                createBtn.disabled = true;
                createBtn.textContent = 'Create';

                await apiCall('/api/remotes', 'POST', {
                    name: remoteName,
                    template: template.name,
                    values: values
                });

                // Reload remotes list and dropdowns
                await loadRemotesList();
                await loadRemotes();

                // Go back to step 1
                showRemotesList();

                createBtn.disabled = false;
                createBtn.textContent = 'Create Remote';

                // Check if the newly created remote needs OAuth and auto-trigger
                await checkAndTriggerOAuthForNewRemote(remoteName);

            } catch (error) {
                alert(`Failed to create remote: ${error.message}`);
                const createBtn = document.getElementById('create-remote-btn');
                createBtn.disabled = false;
                createBtn.textContent = 'Create Remote';
            }
        }

        async function checkAndTriggerOAuthForNewRemote(remoteName) {
            // Find the newly created remote in the list
            const remote = manageRemotesState.remotes.find(r => r.name === remoteName);

            if (!remote) {
                return; // Remote not found, nothing to do
            }

            // Check if it's an OAuth remote with empty token
            if (remote.is_oauth && remote.config && remote.config.token === '') {
                // Wait a moment for the UI to settle, then trigger OAuth refresh
                setTimeout(() => {
                    refreshOAuthToken(remoteName);
                }, 500);
            }
        }

        // Job panel
        function toggleJobPanel() {
            const panel = document.getElementById('job-panel');
            panel.classList.toggle('collapsed');
            // Mark that user manually toggled the panel
            jobPanelManuallyToggled = !panel.classList.contains('collapsed');
        }

        function startJobUpdates() {
            updateJobs();
            jobUpdateInterval = setInterval(updateJobs, 2000);
        }

        async function updateJobs() {
            try {
                const data = await apiCall('/api/jobs?status=running');
                const oldCount = jobsData.jobs.length;
                const previousJobs = new Set(jobsData.jobs.map(j => j.job_id));
                jobsData.jobs = data.jobs || [];
                const newCount = jobsData.jobs.length;
                const currentJobs = new Set(jobsData.jobs.map(j => j.job_id));

                // Detect completed jobs (were tracked, now not in running list)
                const completedJobs = [...trackedJobs].filter(id => !currentJobs.has(id));

                // Auto-refresh destination pane for completed jobs
                for (const jobId of completedJobs) {
                    // Fetch job details to get destination path
                    try {
                        const jobDetails = await apiCall(`/api/jobs/${jobId}`);
                        if (jobDetails && jobDetails.status === 'completed') {
                            // Determine which pane to refresh based on destination
                            const dstPath = jobDetails.dst_path;

                            // Check if destination matches either pane
                            let refreshLeft = false;
                            let refreshRight = false;

                            if (dstPath.includes(':')) {
                                // Remote path
                                const [remote, path] = dstPath.split(':', 2);
                                if (leftPaneState.remote === remote && path.startsWith(leftPaneState.path)) {
                                    refreshLeft = true;
                                }
                                if (rightPaneState.remote === remote && path.startsWith(rightPaneState.path)) {
                                    refreshRight = true;
                                }
                            } else {
                                // Local path
                                if (!leftPaneState.remote && dstPath.startsWith(leftPaneState.path)) {
                                    refreshLeft = true;
                                }
                                if (!rightPaneState.remote && dstPath.startsWith(rightPaneState.path)) {
                                    refreshRight = true;
                                }
                            }

                            // Refresh destination pane(s) with selection preservation
                            if (refreshLeft) {
                                await refreshPane('left', true);
                            }
                            if (refreshRight) {
                                await refreshPane('right', true);
                            }
                        }
                    } catch (err) {
                        console.error(`Failed to auto-refresh after job ${jobId}:`, err);
                    }
                }

                // Update tracked jobs
                trackedJobs = currentJobs;

                // State-based auto-expand/collapse: only change on state transitions
                const panel = document.getElementById('job-panel');
                const isCollapsed = panel.classList.contains('collapsed');
                const currentState = newCount === 0 ? 'empty' : 'non-empty';

                // Only auto-open/close on state transitions (empty ‚Üî non-empty)
                if (!jobPanelManuallyToggled) {
                    // Transition from empty to non-empty: auto-open
                    if (previousJobState === 'empty' && currentState === 'non-empty') {
                        panel.classList.remove('collapsed');
                    }
                    // Transition from non-empty to empty: auto-close
                    else if (previousJobState === 'non-empty' && currentState === 'empty') {
                        panel.classList.add('collapsed');
                    }
                    // No state change: keep panel as is
                }

                previousJobState = currentState;
                renderJobs();
            } catch (error) {
                console.error('Failed to update jobs:', error);
            }
        }

        async function cancelJob(jobId) {
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                updateJobs();
            } catch (error) {
                alert(`Failed to cancel job: ${error.message}`);
            }
        }

        function renderJobs() {
            const container = document.getElementById('job-list');
            const count = document.getElementById('job-count');
            count.textContent = jobsData.jobs.length;

            if (jobsData.jobs.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #999;">No active jobs</p>';
                return;
            }

            // Helper function to format time as "1h23min22s" or "10min5s" or "10s"
            // No unnecessary zeros
            function formatTime(seconds) {
                // Ensure we have a valid positive number
                if (!seconds || seconds < 0) return '0s';

                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;

                if (hours > 0) {
                    return `${hours}h${minutes}min${secs}s`;
                } else if (minutes > 0) {
                    return `${minutes}min${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }

            // Helper function to parse transfer info from rclone text output
            // Text format: "Transferred (bytes):   123.45 MiB / 500 MiB, 25%, 10.5 MiB/s, ETA 35s"
            // or legacy: "Transferred:   123.45 MiB / 500 MiB, 25%, 10.5 MiB/s, ETA 35s"
            function parseTransferInfo(text) {
                if (!text) return null;

                // Look for "Transferred (bytes):" or "Transferred:" line with byte-based progress
                const transferMatch = text.match(/Transferred(?:\s+\(bytes\))?:\s+([0-9.]+)\s*([A-Za-z]+)\s*\/\s*([0-9.]+)\s*([A-Za-z]+).*?([0-9.]+)\s*([A-Za-z/]+)s.*?ETA\s+(.+?)$/m);
                if (transferMatch) {
                    const transferred = transferMatch[1];
                    const transferredUnit = transferMatch[2];
                    const total = transferMatch[3];
                    const totalUnit = transferMatch[4];
                    const speed = transferMatch[5];
                    const speedUnit = transferMatch[6];
                    const eta = transferMatch[7].trim();

                    return {
                        transferred: `${transferred} ${transferredUnit}`,
                        total: `${total} ${totalUnit}`,
                        speed: `${speed} ${speedUnit}/s`,
                        eta: eta
                    };
                }

                return null;
            }

            container.innerHTML = jobsData.jobs.map(job => {
                // Calculate elapsed time with proper timestamp parsing
                let elapsedSec = 0;
                try {
                    // SQLite CURRENT_TIMESTAMP returns UTC time as "YYYY-MM-DD HH:MM:SS"
                    // We need to tell JavaScript it's UTC by adding 'Z' suffix
                    const timestampStr = job.created_at;

                    let createdAt;
                    if (timestampStr.includes('T')) {
                        // Already ISO format, might have 'Z'
                        createdAt = new Date(timestampStr);
                    } else {
                        // SQLite format: "YYYY-MM-DD HH:MM:SS" (UTC)
                        // Convert to ISO format and add 'Z' to indicate UTC
                        createdAt = new Date(timestampStr.replace(' ', 'T') + 'Z');
                    }

                    const now = new Date();

                    // Validate the date is valid
                    if (!isNaN(createdAt.getTime())) {
                        elapsedSec = Math.floor((now - createdAt) / 1000);
                        // Sanity check: if elapsed time is negative or absurdly large, use 0
                        if (elapsedSec < 0 || elapsedSec > 86400 * 365) {
                            console.warn(`Job ${job.job_id}: Invalid elapsed time ${elapsedSec}s from timestamp ${timestampStr}`);
                            elapsedSec = 0;
                        }
                    } else {
                        console.error(`Job ${job.job_id}: Invalid timestamp ${timestampStr}`);
                    }
                } catch (e) {
                    console.error('Error parsing job timestamp:', job.created_at, e);
                    elapsedSec = 0;
                }

                const elapsedStr = formatTime(elapsedSec);

                // Parse transfer information from job text
                const transferInfo = parseTransferInfo(job.text);
                const progress = job.progress || 0;

                // Build transfer status string
                let transferStatus = '';
                if (transferInfo) {
                    // We have detailed transfer info from rclone
                    transferStatus = `${transferInfo.eta} left - ${transferInfo.transferred} out of ${transferInfo.total} (${transferInfo.speed})`;
                } else {
                    // Fallback: calculate ETA from progress or show progress percentage
                    if (progress >= 100) {
                        transferStatus = 'Done';
                    } else if (progress > 0) {
                        // Show calculated ETA if we have progress
                        if (elapsedSec > 1) {
                            const remainingPercent = 100 - progress;
                            const etaSec = Math.floor((elapsedSec / progress) * remainingPercent);
                            const etaStr = formatTime(etaSec);
                            transferStatus = `${etaStr} left (${progress}%)`;
                        } else {
                            transferStatus = `${progress}% - Starting...`;
                        }
                    } else {
                        // No progress yet
                        transferStatus = 'Starting...';
                    }
                }

                return `
                    <div class="job-item ${job.status}">
                        <span class="job-id">Job #${job.job_id} - ${job.operation}</span>
                        <span class="job-path">${job.src_path} ‚Üí ${job.dst_path} (${elapsedStr})</span>
                        <span class="job-time-info">${transferStatus}</span>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${progress}%">
                                ${progress}%
                            </div>
                        </div>
                        <span class="job-status">${job.status}</span>
                        <button class="job-icon-btn cancel" data-action="cancel-job" data-job-id="${job.job_id}" title="Cancel job">√ó</button>
                    </div>
                `;
            }).join('');
        }

        // Interrupted Jobs Dropdown
        function toggleInterruptedJobsDropdown() {
            const list = document.getElementById('interrupted-jobs-list');
            list.classList.toggle('hidden');
        }

        function startInterruptedJobsUpdates() {
            updateInterruptedJobs();
            interruptedJobsInterval = setInterval(updateInterruptedJobs, 5000);
        }

        async function updateInterruptedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=interrupted');
                interruptedJobsData.jobs = data.jobs || [];
                renderInterruptedJobs();
            } catch (error) {
                console.error('Failed to update interrupted jobs:', error);
            }
        }

        function renderInterruptedJobs() {
            const dropdown = document.getElementById('interrupted-jobs-dropdown');
            const list = document.getElementById('interrupted-jobs-list');
            const count = document.getElementById('interrupted-count');

            if (interruptedJobsData.jobs.length === 0) {
                dropdown.classList.add('hidden');
                return;
            }

            dropdown.classList.remove('hidden');
            count.textContent = interruptedJobsData.jobs.length;

            list.innerHTML = interruptedJobsData.jobs.map(job => `
                <div class="interrupted-job-item">
                    <div class="interrupted-job-info">
                        Job #${job.job_id}: ${job.src_path} ‚Üí ${job.dst_path}
                    </div>
                    <div class="interrupted-job-actions">
                        <button class="job-icon-btn resume" data-action="resume-interrupted" data-job-id="${job.job_id}" title="Resume this job">‚ñ∂</button>
                        <button class="job-icon-btn cancel" data-action="cancel-interrupted" data-job-id="${job.job_id}" title="Cancel this job">√ó</button>
                    </div>
                </div>
            `).join('');
        }

        async function cancelInterruptedJob(jobId) {
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                updateInterruptedJobs();
            } catch (error) {
                alert(`Failed to cancel job: ${error.message}`);
            }
        }

        async function resumeInterruptedJobFromDropdown(jobId) {
            try {
                const data = await apiCall(`/api/jobs/${jobId}/resume`, 'POST');
                updateInterruptedJobs();
                updateJobs();  // Refresh active jobs too
            } catch (error) {
                alert(`Failed to resume job: ${error.message}`);
            }
        }

        // Interrupted jobs modal (startup)
        async function checkInterruptedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=resumable');
                if (data.jobs && data.jobs.length > 0) {
                    showInterruptedJobsModal(data.jobs);
                }
            } catch (error) {
                console.error('Failed to check interrupted jobs:', error);
            }
        }

        function showInterruptedJobsModal(jobs) {
            const list = document.getElementById('interrupted-jobs-list');
            list.innerHTML = jobs.map(job => `
                <div style="padding: 8px; background: #f8f9fa; margin: 5px 0; border-radius: 4px;">
                    Job #${job.job_id}: ${job.src_path} ‚Üí ${job.dst_path}
                </div>
            `).join('');
            document.getElementById('interrupted-jobs-modal').style.display = 'flex';
        }

        function closeInterruptedJobsModal() {
            document.getElementById('interrupted-jobs-modal').style.display = 'none';
        }

        async function resumeAllInterruptedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=resumable');
                for (const job of data.jobs) {
                    await apiCall(`/api/jobs/${job.job_id}/resume`, 'POST');
                }
                closeInterruptedJobsModal();
                updateInterruptedJobs();
                updateJobs();
            } catch (error) {
                alert(`Failed to resume jobs: ${error.message}`);
            }
        }

        // Failed Jobs Dropdown
        function toggleFailedJobsDropdown() {
            const list = document.getElementById('failed-jobs-list');
            list.classList.toggle('hidden');
        }

        function startFailedJobsUpdates() {
            updateFailedJobs();
            failedJobsInterval = setInterval(updateFailedJobs, 5000);
        }

        async function updateFailedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=failed');
                failedJobsData.jobs = data.jobs || [];
                renderFailedJobs();
            } catch (error) {
                console.error('Failed to update failed jobs:', error);
            }
        }

        function renderFailedJobs() {
            const dropdown = document.getElementById('failed-jobs-dropdown');
            const list = document.getElementById('failed-jobs-list');
            const count = document.getElementById('failed-count');

            if (failedJobsData.jobs.length === 0) {
                dropdown.classList.add('hidden');
                return;
            }

            dropdown.classList.remove('hidden');
            count.textContent = failedJobsData.jobs.length;

            list.innerHTML = failedJobsData.jobs.map(job => `
                <div class="failed-job-item">
                    <div class="failed-job-info">
                        Job #${job.job_id}: ${job.src_path} ‚Üí ${job.dst_path}
                        ${job.error_text ? '<br><span style="color: #dc3545; font-size: 11px;">' + job.error_text.substring(0, 100) + '...</span>' : ''}
                    </div>
                    <div class="failed-job-actions">
                        <button class="job-icon-btn resume" data-action="resume-failed" data-job-id="${job.job_id}" title="Resume this job">‚ñ∂</button>
                        <button class="job-icon-btn cancel" data-action="cancel-failed" data-job-id="${job.job_id}" title="Cancel this job">√ó</button>
                    </div>
                </div>
            `).join('');
        }

        async function cancelFailedJob(jobId) {
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                updateFailedJobs();
            } catch (error) {
                alert(`Failed to cancel job: ${error.message}`);
            }
        }

        async function resumeFailedJobFromDropdown(jobId) {
            try {
                const data = await apiCall(`/api/jobs/${jobId}/resume`, 'POST');
                updateFailedJobs();
                updateJobs();  // Refresh active jobs too
            } catch (error) {
                alert(`Failed to resume job: ${error.message}`);
            }
        }

        // Quit server
        async function quitServer() {
            const runningCount = jobsData.jobs ? jobsData.jobs.length : 0;
            if (runningCount > 0) {
                const confirmed = confirm(
                    `‚ö†Ô∏è Warning: ${runningCount} job(s) are currently running.\n\n` +
                    `If you quit now, these jobs will be stopped and marked as interrupted.\n\n` +
                    `Are you sure you want to quit?`
                );
                if (!confirmed) return;
            }

            try {
                const data = await apiCall('/api/shutdown', 'POST');
                
                // Replace page content with shutdown message
                document.body.innerHTML = `
                    <div style="max-width:800px; margin:100px auto; text-align:center; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <h1 style="color:#28a745; margin-bottom:20px;">‚úì Server Stopped Successfully</h1>
                        <p style="font-size:18px; color:#666; margin-bottom:30px;">
                            The Motus server has been shut down gracefully.
                        </p>
                        ${data.running_jobs_stopped > 0 ?
                            `<p style="color:#666; margin-bottom:20px;">
                                ${data.running_jobs_stopped} running job(s) were stopped and marked as interrupted.
                                You can resume them next time you start the server.
                            </p>` : ''}
                        <p style="color:#999; font-size:14px;">
                            You can close this window now.
                        </p>
                    </div>
                `;
            } catch (error) {
                alert(`Failed to shutdown server: ${error.message}`);
            }
        }

        // Expert mode functions (existing)
        async function authenticate() {
            authToken = document.getElementById('token').value;
            setAuthToken(authToken);  // Sync with api.js
            document.cookie = `motus_token=${authToken}; path=/; max-age=31536000`;
            try {
                await apiCall('/api/health');
                document.getElementById('auth-status').innerHTML = '<div class="success">‚úì Authenticated successfully</div>';
            } catch (error) {
                document.getElementById('auth-status').innerHTML = `<div class="error">‚úó Authentication failed: ${error.message}</div>`;
            }
        }

        async function listRemotes() {
            try {
                const data = await apiCall('/api/remotes');
                document.getElementById('remotes-output').textContent = 
                    `Found ${data.count} remote(s):\n\n` + data.remotes.join('\n');
            } catch (error) {
                document.getElementById('remotes-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listFiles() {
            const path = document.getElementById('ls-path').value;
            try {
                const data = await apiCall('/api/files/ls', 'POST', { path });

                // Backend returns rclone's format: Name, Size, IsDir, ModTime
                const output = data.files.map(f => {
                    const type = f.IsDir ? 'DIR ' : 'FILE';
                    const size = f.IsDir ? '' : formatFileSize(f.Size);
                    return `${type} ${f.Name.padEnd(40)} ${size}`;
                }).join('\n');

                document.getElementById('ls-output').textContent = output || 'Empty directory';
            } catch (error) {
                document.getElementById('ls-output').textContent = `Error: ${error.message}`;
            }
        }

        async function makeDirectory() {
            const path = document.getElementById('mkdir-path').value;
            try {
                await apiCall('/api/files/mkdir', 'POST', { path });
                document.getElementById('mkdir-status').innerHTML = `<div class="success">‚úì Directory created: ${path}</div>`;
            } catch (error) {
                document.getElementById('mkdir-status').innerHTML = `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function deletePath() {
            const path = document.getElementById('delete-path').value;
            if (!confirm(`Are you sure you want to delete: ${path}?`)) return;
            
            try {
                await apiCall('/api/files/delete', 'POST', { path });
                document.getElementById('delete-status').innerHTML = `<div class="success">‚úì Deleted: ${path}</div>`;
            } catch (error) {
                document.getElementById('delete-status').innerHTML = `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function startCopyJob() {
            const src = document.getElementById('job-src').value.trim();
            const dst = document.getElementById('job-dst').value.trim();

            if (!src || !dst) {
                alert('Please provide both source and destination paths');
                return;
            }

            const copyLinks = document.getElementById('copy-links').checked;

            try {
                const data = await apiCall('/api/jobs/copy', 'POST', {
                    src_path: src,
                    dst_path: dst,
                    copy_links: copyLinks
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML =
                    `<div class="success">‚úì Copy job started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML =
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function resumeJobById() {
            const jobIdValue = document.getElementById('job-id').value.trim();
            const jobId = parseInt(jobIdValue);

            if (!jobId) {
                alert('Please enter a valid job ID');
                return;
            }

            try {
                const data = await apiCall(`/api/jobs/${jobId}/resume`, 'POST');
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML =
                    `<div class="success">‚úì Job resumed (New ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML =
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function startMoveJob() {
            const src = document.getElementById('job-src').value;
            const dst = document.getElementById('job-dst').value;
            
            try {
                const data = await apiCall('/api/jobs/move', 'POST', { 
                    src_path: src, 
                    dst_path: dst
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="success">‚úì Move job started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function checkIntegrity() {
            const src = document.getElementById('job-src').value;
            const dst = document.getElementById('job-dst').value;
            
            try {
                const data = await apiCall('/api/jobs/check', 'POST', { 
                    src_path: src, 
                    dst_path: dst
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="success">‚úì Integrity check started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        // Keep old function for compatibility (not used in UI anymore)
        async function resumeJob() {
            startCopyOrResumeJob();
        }

        async function syncJob() {
            const src = document.getElementById('job-src').value;
            const dst = document.getElementById('job-dst').value;
            
            if (!confirm(
                '‚ö†Ô∏è WARNING: Sync is a DESTRUCTIVE operation!\n\n' +
                'Files in the destination that don\'t exist in the source will be DELETED.\n\n' +
                'Are you sure you want to continue?'
            )) {
                return;
            }
            
            try {
                const data = await apiCall('/api/jobs/sync', 'POST', { 
                    src_path: src, 
                    dst_path: dst
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="success">‚úì Sync job started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function getJobStatus() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }

            try {
                const job = await apiCall(`/api/jobs/${jobId}`);
                const output = `
Job ID: ${job.job_id}
Operation: ${job.operation}
Status: ${job.status}
Progress: ${job.progress}%
Source: ${job.src_path}
Destination: ${job.dst_path}
Created: ${job.created_at}
${job.finished_at ? 'Finished: ' + job.finished_at : ''}
${job.error_text ? 'Error: ' + job.error_text : ''}

Output:
${job.text || '(no output yet)'}
                `.trim();
                document.getElementById('job-status-output').textContent = output;
            } catch (error) {
                document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
            }
        }

        async function showJobLog() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }

            try {
                const data = await apiCall(`/api/jobs/${jobId}/log`);
                const logText = data.log_text || '(no log available)';
                document.getElementById('job-status-output').textContent = `=== Job ${jobId} Log ===\n\n${logText}`;
            } catch (error) {
                document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
            }
        }

        // SSE Progress Watching
        const jobProgressWatcher = new JobProgressWatcher();

        function watchJobProgress() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }

            // Stop any existing connection
            stopWatchingProgress();

            const token = getToken();

            // Show watching indicator
            document.getElementById('watch-progress-btn').style.display = 'none';
            document.getElementById('stop-watch-btn').style.display = 'inline-block';
            document.getElementById('job-status-output').textContent = `üî¥ Watching job ${jobId} (real-time updates)...\n\n`;

            // Start watching using SSE module
            jobProgressWatcher.watch(
                jobId,
                token,
                // onUpdate callback
                (data) => {
                    const timestamp = new Date().toLocaleTimeString();
                    const output = `
üî¥ LIVE UPDATE - ${timestamp}

Job ID: ${data.job_id}
Progress: ${data.progress}%
Status: ${data.finished ? 'Finished' : 'Running'}
Exit Status: ${data.exit_status}
${data.error_text ? 'Error: ' + data.error_text : ''}

Recent Output:
${data.text || '(no output yet)'}
                    `.trim();

                    document.getElementById('job-status-output').textContent = output;

                    // Show completion status when finished
                    if (data.finished) {
                        const finalOutput = output.replace('üî¥ LIVE UPDATE', '‚úì Job Completed');
                        document.getElementById('job-status-output').textContent = finalOutput;
                        stopWatchingProgress();
                    }
                },
                // onError callback
                (error) => {
                    document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
                    stopWatchingProgress();
                }
            );
        }

        function stopWatchingProgress() {
            jobProgressWatcher.stop();
            document.getElementById('watch-progress-btn').style.display = 'inline-block';
            document.getElementById('stop-watch-btn').style.display = 'none';
        }

        async function stopJob() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }
            
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                document.getElementById('job-status-output').textContent = `Job ${jobId} stopped`;
            } catch (error) {
                document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listAllJobs() {
            try {
                const data = await apiCall('/api/jobs');
                const output = data.jobs.map(j =>
                    `#${j.job_id} ${j.operation} ${j.status} ${j.progress}% - ${j.src_path} ‚Üí ${j.dst_path}`
                ).join('\n');
                document.getElementById('all-jobs-output').textContent = output || 'No jobs';
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listRunningJobs() {
            try {
                const data = await apiCall('/api/jobs?status=running');
                const output = data.jobs.map(j =>
                    `#${j.job_id} ${j.operation} ${j.progress}% - ${j.src_path} ‚Üí ${j.dst_path}`
                ).join('\n');
                document.getElementById('all-jobs-output').textContent = output || 'No running jobs';
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listAbortedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=aborted');
                const output = data.jobs.map(j =>
                    `#${j.job_id} ${j.operation} - ${j.src_path} ‚Üí ${j.dst_path}`
                ).join('\n');
                document.getElementById('all-jobs-output').textContent = output || 'No aborted jobs';
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        async function clearStoppedJobs() {
            if (!confirm('Clear all stopped jobs?')) return;

            try {
                const data = await apiCall('/api/jobs/clear_stopped', 'POST');
                document.getElementById('all-jobs-output').textContent =
                    `Cleared ${data.count} stopped job(s)`;
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        // Arrow button functions
        function updateArrowButtons() {
            const leftBtn = document.getElementById('copy-left-btn');
            const rightBtn = document.getElementById('copy-right-btn');

            if (!leftBtn || !rightBtn) return;

            // Enable right arrow if left pane has selections
            if (leftPaneState.selectedIndexes.length > 0) {
                rightBtn.style.opacity = '1';
                rightBtn.style.cursor = 'pointer';
                rightBtn.style.transform = rightBtn.style.transform ? rightBtn.style.transform.replace('scale(1)', 'scale(1.1)') : 'scale(1.1)';
            } else {
                rightBtn.style.opacity = '0.3';
                rightBtn.style.cursor = 'not-allowed';
                rightBtn.style.transform = rightBtn.style.transform ? rightBtn.style.transform.replace('scale(1.1)', 'scale(1)') : 'scale(1)';
            }

            // Enable left arrow if right pane has selections
            if (rightPaneState.selectedIndexes.length > 0) {
                leftBtn.style.opacity = '1';
                leftBtn.style.cursor = 'pointer';
                // Keep rotation but add scale
                const rotation = leftBtn.style.transform.includes('rotate') ? 'rotate(180deg) ' : '';
                leftBtn.style.transform = rotation + 'scale(1.1)';
            } else {
                leftBtn.style.opacity = '0.3';
                leftBtn.style.cursor = 'not-allowed';
                // Keep rotation but reset scale
                const rotation = leftBtn.style.transform.includes('rotate') ? 'rotate(180deg) ' : '';
                leftBtn.style.transform = rotation + 'scale(1)';
            }
        }

        async function copySelectedToRight() {
            if (leftPaneState.selectedIndexes.length === 0) return;

            // Build list of files and paths for confirmation
            const files = leftPaneState.selectedIndexes.map(index => leftPaneState.files[index]);
            const fileNames = files.map(f => f.Name);

            const sourcePath = leftPaneState.remote ?
                `${leftPaneState.remote}:${leftPaneState.path}` :
                leftPaneState.path;
            const destPath = rightPaneState.remote ?
                `${rightPaneState.remote}:${rightPaneState.path}` :
                rightPaneState.path;

            // Store pending operation and show confirmation
            pendingDragDrop = {
                sourcePane: 'left',
                targetPane: 'right',
                sourceState: leftPaneState,
                targetState: rightPaneState,
                indexes: leftPaneState.selectedIndexes,
                files: files
            };

            showDragDropConfirmModal(fileNames, sourcePath, destPath);
        }

        async function copySelectedToLeft() {
            if (rightPaneState.selectedIndexes.length === 0) return;

            // Build list of files and paths for confirmation
            const files = rightPaneState.selectedIndexes.map(index => rightPaneState.files[index]);
            const fileNames = files.map(f => f.Name);

            const sourcePath = rightPaneState.remote ?
                `${rightPaneState.remote}:${rightPaneState.path}` :
                rightPaneState.path;
            const destPath = leftPaneState.remote ?
                `${leftPaneState.remote}:${leftPaneState.path}` :
                leftPaneState.path;

            // Store pending operation and show confirmation
            pendingDragDrop = {
                sourcePane: 'right',
                targetPane: 'left',
                sourceState: rightPaneState,
                targetState: leftPaneState,
                indexes: rightPaneState.selectedIndexes,
                files: files
            };

            showDragDropConfirmModal(fileNames, sourcePath, destPath);
        }

        // ===================================================================
        // All inline event handlers have been replaced with addEventListener
        // No need to expose functions to window object anymore!
    </script>
    <!-- OAuth Refresh Interactive Modal -->
    <div class="modal" id="oauth-interactive-modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header" style="position: relative;">
                üîê OAuth Token Refresh
            </div>
            <div style="padding: 20px;">
                <p style="color: #666; margin-bottom: 20px;">
                    To refresh your OAuth token, please run the following command on your local machine where you have a browser:
                </p>

                <!-- Step 1: Install rclone -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #dee2e6;">
                    <strong style="color: #333;">Step 1: Install rclone (if not already installed)</strong>
                    <p style="margin: 10px 0; color: #666; font-size: 14px;">
                        Download rclone from:
                        <a href="https://rclone.org/downloads/" target="_blank" style="color: #007bff; text-decoration: underline;">https://rclone.org/downloads/</a>
                    </p>
                </div>

                <!-- Step 2: Run authorize command -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #dee2e6;">
                    <strong style="color: #333;">Step 2: Run this command</strong>
                    <div style="background: #2d2d2d; color: #f8f8f2; padding: 12px; border-radius: 4px; margin: 10px 0; font-family: monospace; font-size: 13px; word-break: break-all;">
                        <div id="oauth-authorize-command" style="white-space: pre-wrap;">Loading...</div>
                    </div>
                    <button onclick="copyAuthorizeCommand()" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 8px 16px; cursor: pointer; font-size: 14px; position: relative;">
                        üìã Copy to Clipboard
                        <span id="oauth-copy-tooltip" style="display: none; position: absolute; top: -30px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap;">Copied!</span>
                    </button>
                </div>

                <!-- Step 3: Paste token -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #dee2e6;">
                    <strong style="color: #333;">Step 3: Paste the token here</strong>
                    <p style="margin: 10px 0; color: #666; font-size: 14px;">
                        After running the command, you will see a long token string. Copy and paste it below:
                    </p>
                    <textarea
                        id="oauth-token-input"
                        placeholder="Paste the token string here..."
                        style="width: 100%; min-height: 120px; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; font-family: monospace; font-size: 12px; resize: vertical;"
                    ></textarea>
                </div>

                <!-- Status message -->
                <div id="oauth-status-message" style="display: none; padding: 12px; border-radius: 4px; margin-bottom: 15px;"></div>
            </div>
            <div class="modal-buttons">
                <button onclick="closeOAuthModal()" style="background: #6c757d;">
                    Cancel
                </button>
                <button id="oauth-submit-btn" onclick="submitOAuthToken()" style="background: #28a745;">
                    Submit Token
                </button>
            </div>
        </div>
    </div>

    <style>
        /* Bootstrap-style spinner (kept for potential future use) */
        .spinner-border {
            display: inline-block;
            width: 3rem;
            height: 3rem;
            vertical-align: text-bottom;
            border: 0.35em solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spinner-border-animation 0.75s linear infinite;
            color: #28a745;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        @keyframes spinner-border-animation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</body>
</html>
