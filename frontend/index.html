<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motus - File Transfer Interface</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 0;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: white;
            border-bottom: 2px solid #007bff;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header-left h1 {
            color: #333;
            margin-bottom: 5px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .header-right {
            display: flex;
            gap: 10px;
        }

        .mode-toggle-button, .quit-button, .view-toggle-button, .manage-remotes-button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .manage-remotes-button {
            background: #6f42c1;
            color: white;
        }

        .manage-remotes-button:hover {
            background: #5a32a3;
        }

        .view-dropdown-container {
            position: relative;
        }

        .view-toggle-button {
            background: #28a745;
            color: white;
            padding: 10px 20px;
        }

        .view-toggle-button:hover {
            background: #218838;
        }

        .view-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 5px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
            z-index: 1000;
        }

        .view-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .view-menu-item:last-child {
            border-bottom: none;
        }

        .view-menu-item:hover {
            background: #f5f5f5;
        }

        .mode-toggle-button {
            background: #007bff;
            color: white;
        }

        .mode-toggle-button:hover {
            background: #0056b3;
        }

        .quit-button {
            background: #dc3545;
            color: white;
        }

        .quit-button:hover {
            background: #c82333;
        }

        /* Easy Mode Styles */
        #easy-mode {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panes-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 15px;
            overflow: hidden;
        }

        .pane {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .pane-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            font-weight: 600;
            font-size: 16px;
        }

        .pane.right-pane .pane-header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .pane-toolbar {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toolbar-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .pane-toolbar select,
        .pane-toolbar input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .toolbar-button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            transition: background 0.2s;
        }

        .toolbar-button:hover {
            background: #0056b3;
        }

        .toolbar-button.secondary {
            background: #6c757d;
        }

        .toolbar-button.secondary:hover {
            background: #5a6268;
        }

        .file-grid {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .file-item {
            padding: 15px 10px;
            border: 2px solid transparent;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .file-item:hover {
            background: #f8f9fa;
            border-color: #007bff;
        }

        .file-item.selected {
            background: #e3f2fd;
            border-color: #007bff;
        }

        .file-item.drag-over {
            background: #d4edda;
            border-color: #28a745;
        }

        .file-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .file-name {
            font-size: 13px;
            word-break: break-word;
            color: #333;
        }

        /* List View */
        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .file-list table {
            width: 100%;
            border-collapse: collapse;
        }

        .file-list thead {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            z-index: 10;
        }

        .file-list th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .file-list th.col-name {
            width: auto; /* Take remaining space */
        }

        .file-list th.col-size {
            width: 100px;
            min-width: 80px;
        }

        .file-list th.col-date {
            width: 180px;
            min-width: 150px;
        }

        .file-list th .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            user-select: none;
            z-index: 1;
        }

        .file-list th .resize-handle:hover {
            background: #007bff;
            opacity: 0.5;
        }

        .file-list th:hover {
            background: #e9ecef;
        }

        .file-list th .sort-indicator {
            margin-left: 4px;
            font-size: 10px;
            color: #007bff;
        }

        .file-list .file-row {
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.15s;
        }

        .file-list .file-row:hover {
            background: #f8f9fa;
        }

        .file-list .file-row.selected {
            background: #e3f2fd;
        }

        .file-list .file-row.drag-over {
            background: #d4edda;
        }

        .file-list td {
            padding: 10px 16px;
            font-size: 13px;
            color: #333;
        }

        .file-list td.file-name-col {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-list .file-icon-small {
            font-size: 18px;
        }

        .file-list td.file-size-col {
            text-align: right;
            color: #666;
        }

        .file-list td.file-date-col {
            color: #666;
            white-space: nowrap;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 180px;
            display: none;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #f5f5f5;
        }

        .context-menu-item.danger:hover {
            background: #fee;
            color: #dc3545;
        }

        .context-menu-item.has-submenu {
            position: relative;
        }

        .context-menu-item.has-submenu::after {
            content: '‚ñ∂';
            position: absolute;
            right: 10px;
            font-size: 10px;
        }

        .context-submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 160px;
        }

        .context-menu-item.has-submenu:hover .context-submenu {
            display: block;
        }

        .context-submenu .context-menu-item {
            white-space: nowrap;
        }

        /* Job Panel */
        .job-panel {
            background: white;
            border-top: 2px solid #007bff;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .job-panel.collapsed {
            height: 50px;
        }

        .job-panel:not(.collapsed) {
            height: 300px;
        }

        .job-panel-header {
            padding: 12px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .job-panel-header:hover {
            background: #e9ecef;
        }

        .job-panel-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }

        .collapse-icon {
            transition: transform 0.3s;
        }

        .job-panel.collapsed .collapse-icon {
            transform: rotate(180deg);
        }

        .job-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .job-item {
            background: #f8f9fa;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .job-item.completed {
            border-left-color: #28a745;
        }

        .job-item.failed {
            border-left-color: #dc3545;
        }

        .job-item.cancelled, .job-item.interrupted {
            border-left-color: #ffc107;
        }

        .job-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .job-id {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            white-space: nowrap;
            min-width: 120px;
        }

        .job-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 3px;
            background: #007bff;
            color: white;
            white-space: nowrap;
        }

        .job-path {
            font-size: 12px;
            color: #666;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .job-time-info {
            font-size: 11px;
            color: #666;
            white-space: nowrap;
            min-width: 280px;
            text-align: right;
        }

        .progress-bar-container {
            background: #e9ecef;
            height: 16px;
            border-radius: 8px;
            overflow: hidden;
            width: 120px;
            flex-shrink: 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, #007bff, #0056b3);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: 600;
        }

        .job-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .job-icon-btn {
            background: none;
            color: inherit;
            border: none;
            cursor: pointer;
            font-size: 20px;
            padding: 4px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s;
            opacity: 0.7;
        }

        .job-icon-btn:hover {
            opacity: 1;
        }

        .job-icon-btn.cancel {
            color: #dc3545;
        }

        .job-icon-btn.resume {
            color: #28a745;
        }

        /* Interrupted Jobs Dropdown */
        .interrupted-jobs-dropdown {
            background: #fff8e1;
            border: 1px solid #ffc107;
            border-radius: 6px;
            margin: 15px;
            padding: 0;
            overflow: hidden;
        }

        .interrupted-jobs-header {
            background: #ffc107;
            color: #000;
            padding: 10px 15px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .interrupted-jobs-header:hover {
            background: #ffb300;
        }

        .interrupted-jobs-list {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
        }

        .interrupted-job-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #ffc107;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .interrupted-job-info {
            flex: 1;
            font-size: 13px;
            color: #333;
        }

        .interrupted-job-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Failed Jobs Dropdown */
        .failed-jobs-dropdown {
            background: #ffebee;
            border: 1px solid #dc3545;
            border-radius: 6px;
            margin: 15px;
            padding: 0;
            overflow: hidden;
        }

        .failed-jobs-header {
            background: #dc3545;
            color: white;
            padding: 10px 15px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .failed-jobs-header:hover {
            background: #c82333;
        }

        .failed-jobs-list {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
        }

        .failed-job-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #dc3545;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .failed-job-info {
            flex: 1;
            font-size: 13px;
            color: #333;
        }

        .failed-job-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Expert Mode */
        #expert-mode {
            flex: 1;
            overflow-y: auto;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 6px;
        }

        .section h2 {
            color: #444;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .output {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .hint {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            margin-bottom: 15px;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .success {
            color: #28a745;
            background: #d4edda;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Header (shared between modes) -->
    <div class="header">
        <div class="header-left">
            <h1>Motus</h1>
            <p class="subtitle"><em>Motus et bouche cousue</em> ‚Äî A Web-based File Transfer Interface</p>
        </div>
        <div class="header-right">
            <button class="manage-remotes-button" onclick="openManageRemotesDialog()">
                Manage Remotes
            </button>
            <div class="view-dropdown-container">
                <button class="view-toggle-button" onclick="toggleViewMenu(event)" id="view-menu-btn">
                    View ‚ñæ
                </button>
                <div class="view-dropdown-menu hidden" id="view-dropdown">
                    <div class="view-menu-item" onclick="switchViewMode()" id="view-mode-option">
                        <span id="view-mode-icon">‚äû</span> <span id="view-mode-text">Grid layout</span>
                    </div>
                    <div class="view-menu-item" onclick="toggleHiddenFilesOption()" id="hidden-files-option">
                        <span id="hidden-files-text">Show hidden files</span>
                    </div>
                </div>
            </div>
            <button class="mode-toggle-button" onclick="toggleMode()">
                <span id="mode-button-text">Expert Mode</span>
            </button>
            <button class="quit-button" onclick="quitServer()">Quit</button>
        </div>
    </div>

    <!-- Easy Mode -->
    <div id="easy-mode">
        <div class="panes-container">
            <!-- Left Pane -->
            <div class="pane left-pane">
                <div class="pane-header">üìÇ Server A</div>
                <div class="pane-toolbar">
                    <div class="toolbar-row">
                        <select id="left-remote" onchange="onRemoteChange('left')">
                            <option value="">Local Filesystem</option>
                        </select>
                    </div>
                    <div class="toolbar-row">
                        <input type="text" id="left-path" value="/" placeholder="Path..."
                               onkeypress="handlePathKeypress(event, 'left')" />
                        <button class="toolbar-button secondary" onclick="refreshPane('left', true)" title="Refresh">üîÑ</button>
                    </div>
                </div>
                <div class="file-grid" id="left-files"
                     ondragover="handleDragOver(event, 'left')"
                     ondrop="handleDrop(event, 'left')"
                     ondragleave="handleDragLeave(event, 'left')">
                    <!-- Files will be populated here -->
                </div>
            </div>

            <!-- Arrow Buttons -->
            <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; padding: 0 10px;">
                <button id="copy-right-btn" onclick="copySelectedToRight()" style="background: #007bff; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; transition: opacity 0.3s;" title="Copy selected files to right pane" disabled>‚Üí</button>
                <button id="copy-left-btn" onclick="copySelectedToLeft()" style="background: #007bff; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; transition: opacity 0.3s;" title="Copy selected files to left pane" disabled>‚Üê</button>
            </div>

            <!-- Right Pane -->
            <div class="pane right-pane">
                <div class="pane-header">üìÇ Server B</div>
                <div class="pane-toolbar">
                    <div class="toolbar-row">
                        <select id="right-remote" onchange="onRemoteChange('right')">
                            <option value="">Local Filesystem</option>
                        </select>
                    </div>
                    <div class="toolbar-row">
                        <input type="text" id="right-path" value="/" placeholder="Path..."
                               onkeypress="handlePathKeypress(event, 'right')" />
                        <button class="toolbar-button secondary" onclick="refreshPane('right', true)" title="Refresh">üîÑ</button>
                    </div>
                </div>
                <div class="file-grid" id="right-files"
                     ondragover="handleDragOver(event, 'right')"
                     ondrop="handleDrop(event, 'right')"
                     ondragleave="handleDragLeave(event, 'right')">
                    <!-- Files will be populated here -->
                </div>
            </div>
        </div>

        <!-- Collapsible Job Panel -->
        <div class="job-panel collapsed" id="job-panel">
            <div class="job-panel-header" onclick="toggleJobPanel()">
                <span class="job-panel-title">üìä Active Jobs (<span id="job-count">0</span>)</span>
                <span class="collapse-icon">‚ñº</span>
            </div>
            <div class="job-list" id="job-list">
                <!-- Jobs will be populated here -->
            </div>
        </div>

        <!-- Interrupted Jobs Dropdown -->
        <div class="interrupted-jobs-dropdown hidden" id="interrupted-jobs-dropdown">
            <div class="interrupted-jobs-header" onclick="toggleInterruptedJobsDropdown()">
                <span>‚ö†Ô∏è Interrupted Jobs (<span id="interrupted-count">0</span>)</span>
                <span class="collapse-icon">‚ñº</span>
            </div>
            <div class="interrupted-jobs-list hidden" id="interrupted-jobs-list">
                <!-- Interrupted jobs will be populated here -->
            </div>
        </div>

        <!-- Failed Jobs Dropdown -->
        <div class="failed-jobs-dropdown hidden" id="failed-jobs-dropdown">
            <div class="failed-jobs-header" onclick="toggleFailedJobsDropdown()">
                <span>‚ùå Failed Jobs (<span id="failed-count">0</span>)</span>
                <span class="collapse-icon">‚ñº</span>
            </div>
            <div class="failed-jobs-list hidden" id="failed-jobs-list">
                <!-- Failed jobs will be populated here -->
            </div>
        </div>
    </div>

    <!-- Expert Mode (existing UI) -->
    <div id="expert-mode" class="hidden">
        <div class="container" style="margin-top: 0;">
            <!-- Authentication -->
            <div class="section">
                <h2>üîê Authentication</h2>
                <div class="form-group">
                    <label>Access Token:</label>
                    <input type="text" id="token" placeholder="Enter your token (check server logs)" />
                    <div class="hint">The token is displayed when you start the server</div>
                </div>
                <button onclick="authenticate()">Authenticate</button>
                <div id="auth-status"></div>
            </div>

            <!-- Available Remotes -->
            <div class="section">
                <h2>üåê Available Remotes</h2>
                <div class="hint">
                    Configure remotes using: <code>rclone config</code><br>
                    List remotes using: <code>rclone listremotes</code>
                </div>
                <button onclick="listRemotes()">List Remotes</button>
                <div class="output" id="remotes-output"></div>
            </div>

            <!-- File Operations -->
            <div class="section">
                <h2>üìÅ File Operations</h2>
                
                <div class="form-group">
                    <label>Path:</label>
                    <input type="text" id="ls-path" placeholder="/path or remote:/path" value="/"
                           onkeypress="if(event.key === 'Enter') listFiles()" />
                    <div class="hint">Example: /tmp or myS3:/bucket/folder</div>
                </div>
                <button onclick="listFiles()">List Files</button>
                <div class="output" id="ls-output"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <div class="form-group">
                    <label>Create Directory:</label>
                    <input type="text" id="mkdir-path" placeholder="/path/to/newdir or remote:/path/newdir"
                           onkeypress="if(event.key === 'Enter') makeDirectory()" />
                </div>
                <button onclick="makeDirectory()">Create Directory</button>
                <div id="mkdir-status"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <div class="form-group">
                    <label>Delete Path:</label>
                    <input type="text" id="delete-path" placeholder="/path or remote:/path"
                           onkeypress="if(event.key === 'Enter') deletePath()" />
                </div>
                <button onclick="deletePath()" style="background: #dc3545;">Delete</button>
                <div id="delete-status"></div>
            </div>

            <!-- Job Management -->
            <div class="section">
                <h2>üì¶ Job Management</h2>
                
                <div class="form-group">
                    <label>Source Path:</label>
                    <input type="text" id="job-src" placeholder="/source or remote:/source"
                           onkeypress="handleJobPathKeypress(event, 'src')" />
                </div>
                <div class="form-group">
                    <label>Destination Path:</label>
                    <input type="text" id="job-dst" placeholder="/destination or remote:/destination"
                           onkeypress="handleJobPathKeypress(event, 'dst')" />
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="copy-links" /> Follow Symlinks
                    </label>
                </div>
                <button onclick="startCopyJob()">Copy</button>
                <button onclick="startMoveJob()" style="background: #ffc107; color: #000;">Move</button>
                <button onclick="checkIntegrity()" style="background: #17a2b8;">Check Integrity</button>
                <button onclick="syncJob()" style="background: #dc3545;">Sync (Destructive)</button>
                <div id="job-start-status"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <div class="form-group">
                    <label>Job ID:</label>
                    <input type="number" id="job-id" placeholder="Enter job ID"
                           onkeypress="if(event.key === 'Enter') getJobStatus()" />
                    <div class="hint">Press ENTER to get status</div>
                </div>
                <button onclick="getJobStatus()">Get Status</button>
                <button onclick="watchJobProgress()" style="background: #17a2b8;" id="watch-progress-btn">Watch Progress (SSE)</button>
                <button onclick="stopWatchingProgress()" style="background: #6c757d; display: none;" id="stop-watch-btn">Stop Watching</button>
                <button onclick="showJobLog()" style="background: #6c757d;">Show Log</button>
                <button onclick="resumeJobById()" style="background: #28a745;">Resume</button>
                <button onclick="stopJob()" style="background: #dc3545;">Stop Job</button>
                <div class="output" id="job-status-output"></div>

                <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">

                <button onclick="listAllJobs()">List All Jobs</button>
                <button onclick="listRunningJobs()" style="background: #28a745;">List Running</button>
                <button onclick="listAbortedJobs()" style="background: #ffc107; color: #000;">List Aborted</button>
                <button onclick="clearStoppedJobs()" style="background: #6c757d;">Clear All Stopped Jobs</button>
                <div class="output" id="all-jobs-output"></div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" onclick="contextMenuAction('newfolder')">üìÅ Create Folder</div>
        <div class="context-menu-item" onclick="contextMenuAction('rename')">‚úèÔ∏è Rename</div>
        <div class="context-menu-item danger" onclick="contextMenuAction('delete')">üóëÔ∏è Delete</div>
        <div class="context-menu-item has-submenu">
            üìä Sort by
            <div class="context-submenu">
                <div class="context-menu-item" onclick="contextMenuSortBy('name', true)">Name (A-Z)</div>
                <div class="context-menu-item" onclick="contextMenuSortBy('name', false)">Name (Z-A)</div>
                <div class="context-menu-item" onclick="contextMenuSortBy('size', true)">Size (Smallest)</div>
                <div class="context-menu-item" onclick="contextMenuSortBy('size', false)">Size (Largest)</div>
                <div class="context-menu-item" onclick="contextMenuSortBy('date', true)">Date (Oldest)</div>
                <div class="context-menu-item" onclick="contextMenuSortBy('date', false)">Date (Newest)</div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="interrupted-jobs-modal">
        <div class="modal-content">
            <div class="modal-header">‚ö†Ô∏è Interrupted Jobs Found</div>
            <p>Some jobs were interrupted when the server was last stopped. Would you like to resume them?</p>
            <div id="interrupted-jobs-list"></div>
            <div class="modal-buttons">
                <button onclick="closeInterruptedJobsModal()">Skip</button>
                <button onclick="resumeAllInterruptedJobs()" style="background: #28a745;">Resume All</button>
            </div>
        </div>
    </div>

    <div class="modal" id="rename-modal">
        <div class="modal-content">
            <div class="modal-header">‚úèÔ∏è Rename</div>
            <div class="form-group">
                <label>New name:</label>
                <input type="text" id="rename-input"
                       onkeypress="if(event.key === 'Enter') confirmRename()" />
            </div>
            <div class="modal-buttons">
                <button onclick="closeRenameModal()">Cancel</button>
                <button onclick="confirmRename()" style="background: #28a745;">Rename</button>
            </div>
        </div>
    </div>

    <div class="modal" id="create-folder-modal">
        <div class="modal-content">
            <div class="modal-header">üìÅ Create New Folder</div>
            <div class="form-group">
                <label>Folder name:</label>
                <input type="text" id="create-folder-input"
                       onkeypress="if(event.key === 'Enter') confirmCreateFolder()" />
            </div>
            <div class="modal-buttons">
                <button onclick="closeCreateFolderModal()">Cancel</button>
                <button onclick="confirmCreateFolder()" style="background: #28a745;">Create</button>
            </div>
        </div>
    </div>

    <div class="modal" id="delete-confirm-modal">
        <div class="modal-content">
            <div class="modal-header">‚ö†Ô∏è Confirm Delete</div>
            <p style="margin-bottom: 15px; color: #dc3545; font-weight: 500;">
                This action is irreversible! There is no recycle bin.
            </p>
            <p id="delete-confirm-message">Are you sure you want to delete the selected items?</p>
            <div class="modal-buttons">
                <button onclick="closeDeleteConfirmModal()">Cancel</button>
                <button onclick="confirmDelete()" style="background: #dc3545;">Delete</button>
            </div>
        </div>
    </div>

    <!-- Drag and Drop Confirmation Modal -->
    <div class="modal" id="drag-drop-confirm-modal">
        <div class="modal-content">
            <div class="modal-header">üìã Confirm Copy Operation</div>
            <p style="margin-bottom: 15px; color: #333; font-weight: 500;">
                Copy the following files?
            </p>
            <div style="margin-bottom: 15px; background: #f8f9fa; padding: 12px; border-radius: 6px; max-height: 200px; overflow-y: auto;">
                <div id="drag-drop-file-list" style="font-family: monospace; font-size: 12px; color: #333;"></div>
            </div>
            <div style="margin-bottom: 15px; background: #e3f2fd; padding: 12px; border-radius: 6px;">
                <div style="font-weight: 600; color: #1976d2; margin-bottom: 8px;">Source:</div>
                <div id="drag-drop-source" style="font-family: monospace; font-size: 12px; color: #333; word-break: break-all;"></div>
            </div>
            <div style="margin-bottom: 20px; background: #e8f5e9; padding: 12px; border-radius: 6px;">
                <div style="font-weight: 600; color: #388e3c; margin-bottom: 8px;">Destination:</div>
                <div id="drag-drop-destination" style="font-family: monospace; font-size: 12px; color: #333; word-break: break-all;"></div>
            </div>
            <div class="modal-buttons">
                <button onclick="closeDragDropConfirmModal()">Cancel</button>
                <button onclick="confirmDragDrop()" style="background: #28a745;">Copy</button>
            </div>
        </div>
    </div>

    <!-- Manage Remotes Modal -->
    <div class="modal" id="manage-remotes-modal">
        <div class="modal-content" style="max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
            <!-- Step 1: List Remotes -->
            <div id="manage-remotes-step1" class="manage-remotes-step" style="display: flex; flex-direction: column; max-height: 80vh;">
                <div class="modal-header" style="position: relative;">
                    üîß Manage Remotes
                    <button onclick="closeManageRemotesDialog()" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close">√ó</button>
                </div>
                <div id="remotes-list-container" style="margin-bottom: 15px; overflow-y: auto; max-height: 50vh;">
                    <p style="color: #666; text-align: center;">Loading remotes...</p>
                </div>
                <div class="modal-buttons">
                    <button id="add-remote-btn" onclick="showTemplateSelection()" style="background: #28a745; display: none;">+ Add Remote</button>
                </div>
            </div>

            <!-- Step 2: Select Template -->
            <div id="manage-remotes-step2" class="manage-remotes-step" style="display: none; flex-direction: column; max-height: 80vh;">
                <div class="modal-header" style="position: relative;">
                    üìã Select Template
                    <button onclick="showRemotesList()" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close and return to remotes list">√ó</button>
                </div>
                <p style="margin-bottom: 15px; color: #666;">Choose a template for the new remote:</p>
                <div id="templates-list-container" style="overflow-y: auto; max-height: 50vh; margin-bottom: 15px;">
                    <p style="color: #666; text-align: center;">Loading templates...</p>
                </div>
                <div class="modal-buttons">
                    <button onclick="showRemotesList()">Back</button>
                    <button id="template-next-btn" onclick="showRemoteForm()" style="background: #007bff;" disabled>Next</button>
                </div>
            </div>

            <!-- Step 3: Configure Remote -->
            <div id="manage-remotes-step3" class="manage-remotes-step" style="display: none; flex-direction: column; max-height: 80vh;">
                <div class="modal-header" style="position: relative;">
                    ‚öôÔ∏è Configure Remote
                    <button onclick="showRemotesList()" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close and return to remotes list">√ó</button>
                </div>
                <div id="remote-form-container" style="overflow-y: auto; max-height: 50vh; margin-bottom: 15px;">
                    <!-- Form will be generated dynamically -->
                </div>
                <div class="modal-buttons">
                    <button onclick="showTemplateSelection()">Back</button>
                    <button id="create-remote-btn" onclick="createRemote()" style="background: #28a745;">Create Remote</button>
                </div>
            </div>
        </div>
    </div>

    <!-- View Remote Config Modal -->
    <div class="modal" id="view-remote-config-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header" style="position: relative;">
                üìÑ Remote Configuration
                <button onclick="closeViewRemoteConfigModal()" style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; line-height: 1;" title="Close">√ó</button>
            </div>
            <div id="remote-config-content" style="margin-bottom: 15px; max-height: 50vh; overflow-y: auto;">
                <!-- Config will be populated here -->
            </div>
            <div class="modal-buttons">
                <button onclick="copyRemoteConfigToClipboard()" style="background: #28a745; position: relative;">
                    üìã Copy to Clipboard
                    <span id="copy-tooltip" style="display: none; position: absolute; top: -30px; left: 50%; transform: translateX(-50%); background: #333; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap;">Copied!</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Edit Remote Config Modal -->
    <div class="modal" id="edit-remote-config-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">‚úèÔ∏è Edit Remote Configuration</div>
            <div style="margin-bottom: 15px;">
                <p style="color: #666; margin-bottom: 10px;">Edit the rclone configuration for this remote. You can rename the remote by changing the value between [brackets].</p>
                <textarea id="edit-remote-config-text"
                          style="width: 100%; min-height: 300px; max-height: 50vh; font-family: monospace; font-size: 12px; padding: 12px; border: 1px solid #ddd; border-radius: 4px; resize: vertical;"
                          placeholder="[remote_name]
type = s3
..."></textarea>
            </div>
            <div class="modal-buttons">
                <button onclick="closeEditRemoteConfigModal()">Cancel</button>
                <button onclick="saveRemoteConfig()" style="background: #28a745;">Save</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentMode = 'easy';  // Will be set from config
        let authToken = '';
        let leftPaneState = {
            remote: '',
            path: '/',
            files: [],
            selectedIndexes: [],
            sortBy: 'name',  // name, size, date
            sortAsc: true
        };
        let rightPaneState = {
            remote: '',
            path: '/',
            files: [],
            selectedIndexes: [],
            sortBy: 'name',
            sortAsc: true
        };
        let viewMode = 'list';  // 'grid' or 'list' - default to list
        let showHiddenFiles = false;  // show/hide files starting with . - default hidden
        let lastFocusedPane = 'left';  // Track which pane was last focused
        let contextMenuState = {
            pane: null,
            items: []
        };
        let jobsData = {
            jobs: []
        };
        let interruptedJobsData = {
            jobs: []
        };
        let failedJobsData = {
            jobs: []
        };
        let jobUpdateInterval = null;
        let interruptedJobsInterval = null;
        let failedJobsInterval = null;
        let createFolderPane = null;
        let jobPanelManuallyToggled = false;  // Track if user manually toggled the panel
        let previousJobState = 'empty';  // Track previous state: 'empty' or 'non-empty'
        let trackedJobs = new Set();  // Track running jobs for completion detection
        let pendingDragDrop = null;  // Store pending drag-drop operation for confirmation

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Try to load token from URL
            const urlParams = new URLSearchParams(window.location.search);
            const tokenFromUrl = urlParams.get('token');
            if (tokenFromUrl) {
                authToken = tokenFromUrl;
                document.getElementById('token').value = tokenFromUrl;
                // Set cookie
                document.cookie = `motus_token=${tokenFromUrl}; path=/; max-age=31536000`;
            } else {
                // Try to load from cookie
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    const [name, value] = cookie.trim().split('=');
                    if (name === 'motus_token') {
                        authToken = value;
                        document.getElementById('token').value = value;
                        break;
                    }
                }
            }

            // Load config to get default mode
            try {
                const config = await apiCall('/api/config');
                currentMode = config.default_mode || 'easy';
                setMode(currentMode);
            } catch (e) {
                console.error('Failed to load config:', e);
                setMode('easy');
            }

            // Load user preferences from backend
            await loadPreferences();

            // Load remotes for easy mode
            if (currentMode === 'easy') {
                await loadRemotes();
                // If using Local Filesystem, start in home directory
                if (leftPaneState.remote === '') {
                    leftPaneState.path = '~/';
                    document.getElementById('left-path').value = '~/';
                }
                if (rightPaneState.remote === '') {
                    rightPaneState.path = '~/';
                    document.getElementById('right-path').value = '~/';
                }
                await refreshPane('left');
                await refreshPane('right');
                startJobUpdates();
                startInterruptedJobsUpdates();
                startFailedJobsUpdates();
            }

            // Check for interrupted jobs modal (only on startup)
            checkInterruptedJobs();

            // Hide context menu and view dropdown on click outside
            document.addEventListener('click', () => {
                document.getElementById('context-menu').style.display = 'none';
                document.getElementById('view-dropdown').classList.add('hidden');
            });

            // Add context menu to empty container backgrounds
            ['left', 'right'].forEach(pane => {
                const container = document.getElementById(`${pane}-files`);
                container.addEventListener('contextmenu', (e) => {
                    // Only show menu if clicking on container itself or table, not on child file elements
                    if (e.target === container || e.target.tagName === 'TABLE') {
                        e.preventDefault();
                        const state = pane === 'left' ? leftPaneState : rightPaneState;
                        // Clear selection when right-clicking on empty space
                        if (state.selectedIndexes.length > 0) {
                            state.selectedIndexes = [];
                            renderFiles(pane);
                        }
                        showContextMenu(e, pane);
                    }
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Check if any modal is open
                const renameModal = document.getElementById('rename-modal');
                const deleteModal = document.getElementById('delete-confirm-modal');
                const createFolderModal = document.getElementById('create-folder-modal');
                const dragDropModal = document.getElementById('drag-drop-confirm-modal');
                const editRemoteModal = document.getElementById('edit-remote-config-modal');
                const viewRemoteModal = document.getElementById('view-remote-config-modal');

                // Handle Escape key
                if (e.key === 'Escape') {
                    // Close modals
                    if (renameModal.style.display === 'flex') {
                        closeRenameModal();
                        return;
                    }
                    if (deleteModal.style.display === 'flex') {
                        closeDeleteConfirmModal();
                        return;
                    }
                    if (createFolderModal.style.display === 'flex') {
                        closeCreateFolderModal();
                        return;
                    }
                    if (dragDropModal.style.display === 'flex') {
                        closeDragDropConfirmModal();
                        return;
                    }
                    if (editRemoteModal.style.display === 'flex') {
                        closeEditRemoteConfigModal();
                        return;
                    }
                    if (viewRemoteModal.style.display === 'flex') {
                        closeViewRemoteConfigModal();
                        return;
                    }
                    // Close menus
                    document.getElementById('context-menu').style.display = 'none';
                    document.getElementById('view-dropdown').classList.add('hidden');
                    return;
                }

                // Handle Enter key for modals
                if (e.key === 'Enter') {
                    if (renameModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmRename();
                        return;
                    }
                    if (deleteModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmDelete();
                        return;
                    }
                    if (createFolderModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmCreateFolder();
                        return;
                    }
                    if (dragDropModal.style.display === 'flex') {
                        e.preventDefault();
                        confirmDragDrop();
                        return;
                    }
                }

                // Ignore other shortcuts when typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // F2 - Rename selected file/folder
                if (e.key === 'F2') {
                    e.preventDefault();
                    const state = lastFocusedPane === 'left' ? leftPaneState : rightPaneState;
                    if (state.selectedIndexes.length === 1) {
                        const file = state.files[state.selectedIndexes[0]];
                        contextMenuState.pane = lastFocusedPane;
                        contextMenuState.items = [file];
                        showRenameModal(file.Name);
                    }
                    return;
                }

                // Delete - Delete selected files/folders
                if (e.key === 'Delete') {
                    e.preventDefault();
                    const state = lastFocusedPane === 'left' ? leftPaneState : rightPaneState;
                    if (state.selectedIndexes.length > 0) {
                        contextMenuState.pane = lastFocusedPane;
                        contextMenuState.items = state.selectedIndexes.map(i => state.files[i]);
                        showDeleteConfirmModal();
                    }
                    return;
                }
            });

            // Click whitespace to deselect and track focused pane
            document.getElementById('left-files').addEventListener('click', (e) => {
                lastFocusedPane = 'left';
                if (e.target.id === 'left-files' || e.target.classList.contains('file-grid') || e.target.classList.contains('file-list')) {
                    leftPaneState.selectedIndexes = [];
                    renderFiles('left');
                }
            });
            document.getElementById('right-files').addEventListener('click', (e) => {
                lastFocusedPane = 'right';
                if (e.target.id === 'right-files' || e.target.classList.contains('file-grid') || e.target.classList.contains('file-list')) {
                    rightPaneState.selectedIndexes = [];
                    renderFiles('right');
                }
            });
        });

        // View menu toggle
        function toggleViewMenu(event) {
            event.stopPropagation();
            const menu = document.getElementById('view-dropdown');
            menu.classList.toggle('hidden');
            updateViewMenuItems();
        }

        function updateViewMenuItems() {
            // Update view mode option to show the OPPOSITE of current mode
            const modeIcon = document.getElementById('view-mode-icon');
            const modeText = document.getElementById('view-mode-text');
            if (viewMode === 'grid') {
                modeIcon.textContent = '‚ò∞';
                modeText.textContent = 'List layout';
            } else {
                modeIcon.textContent = '‚äû';
                modeText.textContent = 'Grid layout';
            }

            // Update hidden files text based on current state
            const hiddenText = document.getElementById('hidden-files-text');
            hiddenText.textContent = showHiddenFiles ? "Don't show hidden files" : "Show hidden files";
        }

        function switchViewMode() {
            viewMode = viewMode === 'grid' ? 'list' : 'grid';
            document.getElementById('view-dropdown').classList.add('hidden');

            // Save preference to backend
            savePreferences();

            // Re-render both panes
            renderFiles('left');
            renderFiles('right');
        }

        function toggleHiddenFilesOption() {
            showHiddenFiles = !showHiddenFiles;
            document.getElementById('view-dropdown').classList.add('hidden');

            // Save preference to backend
            savePreferences();

            // Re-render both panes
            renderFiles('left');
            renderFiles('right');
        }

        async function savePreferences() {
            try {
                await apiCall('/api/preferences', 'POST', {
                    view_mode: viewMode,
                    show_hidden_files: showHiddenFiles
                });
            } catch (error) {
                console.error('Failed to save preferences:', error);
            }
        }

        async function loadPreferences() {
            try {
                const prefs = await apiCall('/api/preferences');
                if (prefs.view_mode) {
                    viewMode = prefs.view_mode;
                }
                if (prefs.show_hidden_files !== undefined) {
                    showHiddenFiles = prefs.show_hidden_files;
                }
            } catch (error) {
                console.error('Failed to load preferences:', error);
            }
        }

        // Path construction helper
        function buildPath(basePath, filename) {
            // Normalize path to avoid double slashes
            const normalized = basePath.endsWith('/') ? basePath.slice(0, -1) : basePath;
            return `${normalized}/${filename}`;
        }

        // Sorting helpers
        function sortFiles(files, sortBy, sortAsc) {
            const sorted = [...files];
            sorted.sort((a, b) => {
                // Directories first
                if (a.IsDir !== b.IsDir) {
                    return a.IsDir ? -1 : 1;
                }

                let comparison = 0;
                if (sortBy === 'name') {
                    comparison = a.Name.localeCompare(b.Name);
                } else if (sortBy === 'size') {
                    comparison = (a.Size || 0) - (b.Size || 0);
                } else if (sortBy === 'date') {
                    const dateA = new Date(a.ModTime || 0);
                    const dateB = new Date(b.ModTime || 0);
                    comparison = dateA - dateB;
                }

                return sortAsc ? comparison : -comparison;
            });
            return sorted;
        }

        function setSortBy(pane, field) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            if (state.sortBy === field) {
                state.sortAsc = !state.sortAsc;
            } else {
                state.sortBy = field;
                state.sortAsc = true;
            }
            renderFiles(pane);
        }

        // Column resizing
        let resizingColumn = null;
        let startX = 0;
        let startWidth = 0;

        function startColumnResize(e, th) {
            e.preventDefault();
            e.stopPropagation();

            resizingColumn = th;
            startX = e.pageX;
            startWidth = th.offsetWidth;

            document.addEventListener('mousemove', doColumnResize);
            document.addEventListener('mouseup', stopColumnResize);
        }

        function doColumnResize(e) {
            if (!resizingColumn) return;

            const diff = e.pageX - startX;
            const newWidth = startWidth + diff;

            // Enforce minimum width
            const minWidth = parseInt(window.getComputedStyle(resizingColumn).minWidth) || 50;
            if (newWidth >= minWidth) {
                resizingColumn.style.width = newWidth + 'px';
            }
        }

        function stopColumnResize() {
            resizingColumn = null;
            document.removeEventListener('mousemove', doColumnResize);
            document.removeEventListener('mouseup', stopColumnResize);
        }

        function formatFileSize(bytes) {
            if (bytes === undefined || bytes === null || bytes < 0) return '';
            if (bytes === 0) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let size = bytes;
            let unitIndex = 0;
            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }
            return `${size.toFixed(1)} ${units[unitIndex]}`;
        }

        function formatFileDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        }

        // API helper
        async function apiCall(endpoint, method = 'GET', body = null) {
            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                }
            };

            if (authToken) {
                options.headers['Authorization'] = `token ${authToken}`;
            }

            if (body) {
                options.body = JSON.stringify(body);
            }

            const response = await fetch(endpoint, options);
            if (!response.ok) {
                const error = await response.json().catch(() => ({ error: response.statusText }));
                throw new Error(error.error || 'Request failed');
            }
            return response.json();
        }

        // Utility functions
        function expandTildePath(path) {
            // Expand ~ to home directory (platform-aware)
            if (path.startsWith('~')) {
                // On Linux/Mac, replace with /home/username or /Users/username
                // We'll use a simple heuristic - if path starts with ~, replace with empty
                // The backend will handle actual expansion via os.path.expanduser or similar
                return path;  // Send as-is, backend should handle ~
            }
            return path;
        }

        function resolveRelativePath(basePath, relativePath) {
            // If relative path starts with /, it's absolute
            if (relativePath.startsWith('/')) {
                return relativePath;
            }
            // Otherwise, join with base path
            const base = basePath.endsWith('/') ? basePath : basePath + '/';
            return base + relativePath;
        }

        // ENTER key handlers
        function handlePathKeypress(event, pane) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const state = pane === 'left' ? leftPaneState : rightPaneState;
                const inputPath = document.getElementById(`${pane}-path`).value;

                // Check if path changed
                if (inputPath !== state.path) {
                    browsePath(pane);
                } else {
                    refreshPane(pane);
                }
            }
        }

        function handleJobPathKeypress(event, field) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const srcValue = document.getElementById('job-src').value.trim();
                const dstValue = document.getElementById('job-dst').value.trim();

                if (field === 'src') {
                    // If in source field
                    if (srcValue && !dstValue) {
                        // Move to destination field
                        document.getElementById('job-dst').focus();
                    } else if (srcValue && dstValue) {
                        // Both filled, start copy
                        startCopyJob();
                    }
                } else if (field === 'dst') {
                    // If in destination field
                    if (srcValue && dstValue) {
                        // Both filled, start copy
                        startCopyJob();
                    }
                }
            }
        }

        // Mode switching
        function toggleMode() {
            setMode(currentMode === 'easy' ? 'expert' : 'easy');
        }

        function setMode(mode) {
            currentMode = mode;
            if (mode === 'easy') {
                document.getElementById('easy-mode').classList.remove('hidden');
                document.getElementById('expert-mode').classList.add('hidden');
                document.getElementById('mode-button-text').textContent = 'Expert Mode';
                if (!jobUpdateInterval) {
                    loadRemotes();
                    refreshPane('left');
                    refreshPane('right');
                    startJobUpdates();
                    startInterruptedJobsUpdates();
                }
            } else {
                document.getElementById('easy-mode').classList.add('hidden');
                document.getElementById('expert-mode').classList.remove('hidden');
                document.getElementById('mode-button-text').textContent = 'Easy Mode';
                if (jobUpdateInterval) {
                    clearInterval(jobUpdateInterval);
                    jobUpdateInterval = null;
                }
                if (interruptedJobsInterval) {
                    clearInterval(interruptedJobsInterval);
                    interruptedJobsInterval = null;
                }
            }
        }

        // Load remotes
        async function loadRemotes() {
            try {
                const data = await apiCall('/api/remotes');
                const leftSelect = document.getElementById('left-remote');
                const rightSelect = document.getElementById('right-remote');

                // Clear existing options except first
                leftSelect.innerHTML = '<option value="">Local Filesystem</option>';
                rightSelect.innerHTML = '<option value="">Local Filesystem</option>';

                data.remotes.forEach(remote => {
                    leftSelect.innerHTML += `<option value="${remote.name}">${remote.name}</option>`;
                    rightSelect.innerHTML += `<option value="${remote.name}">${remote.name}</option>`;
                });
            } catch (error) {
                console.error('Failed to load remotes:', error);
            }
        }

        // Remote change handler
        let isReverting = false;

        async function onRemoteChange(pane) {
            // Prevent recursion during revert
            if (isReverting) {
                isReverting = false;
                return;
            }

            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const select = document.getElementById(`${pane}-remote`);
            const pathInput = document.getElementById(`${pane}-path`);
            const oldRemote = state.remote;
            const oldPath = state.path;
            const newRemote = select.value;

            // When switching to Local Filesystem, go to home
            const newPath = (newRemote === '') ? '~/' : '/';

            state.remote = newRemote;
            state.path = newPath;
            pathInput.value = newPath;

            try {
                await refreshPane(pane);
            } catch (error) {
                // Revert to old remote and path on error
                isReverting = true;
                state.remote = oldRemote;
                state.path = oldPath;
                select.value = oldRemote;
                pathInput.value = oldPath;

                alert(`Failed to access remote: ${error.message}`);
            }
        }

        // Browse path
        function browsePath(pane) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            let path = document.getElementById(`${pane}-path`).value;
            // Expand tilde
            path = expandTildePath(path);
            state.path = path;
            document.getElementById(`${pane}-path`).value = path;
            refreshPane(pane);
        }

        // Refresh pane
        async function refreshPane(pane, preserveSelection = false) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const fullPath = state.remote ? `${state.remote}:${state.path}` : state.path;

            // Save current selection if preserving
            const selectedFileNames = preserveSelection ?
                state.selectedIndexes.map(idx => state.files[idx]?.Name).filter(n => n) :
                [];

            console.log(`refreshPane(${pane}, preserveSelection=${preserveSelection}), saving ${selectedFileNames.length} selected files:`, selectedFileNames);

            try {
                const data = await apiCall('/api/files/ls', 'POST', { path: fullPath });
                state.files = data.files || [];

                if (preserveSelection && selectedFileNames.length > 0) {
                    // Restore selection by matching file names
                    state.selectedIndexes = [];
                    selectedFileNames.forEach(name => {
                        const idx = state.files.findIndex(f => f.Name === name);
                        if (idx !== -1) {
                            state.selectedIndexes.push(idx);
                            console.log(`Restored selection: ${name} at index ${idx}`);
                        } else {
                            console.log(`Could not restore selection: ${name} not found`);
                        }
                    });
                    console.log(`Selection preservation: restored ${state.selectedIndexes.length} of ${selectedFileNames.length} files`);
                } else {
                    state.selectedIndexes = [];
                }

                renderFiles(pane);
            } catch (error) {
                console.error(`Failed to refresh ${pane} pane:`, error);
                alert(`Error: ${error.message}`);
                throw error; // Re-throw so callers can handle it
            }
        }

        // Render files in grid or list view
        function renderFiles(pane) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const container = document.getElementById(`${pane}-files`);

            // Filter hidden files if needed
            let filesToShow = state.files;
            if (!showHiddenFiles) {
                filesToShow = state.files.filter(f => !f.Name.startsWith('.'));
            }

            // Add original index to each file before sorting
            const filesWithIndex = filesToShow.map((file, idx) => ({
                ...file,
                _originalIndex: state.files.indexOf(file)
            }));

            // Sort files
            const sortedFiles = sortFiles(filesWithIndex, state.sortBy, state.sortAsc);

            // Store visual order mapping for Shift+click range selection
            // Maps original index -> visual position
            state.visualOrder = {};
            sortedFiles.forEach((file, visualPos) => {
                state.visualOrder[file._originalIndex] = visualPos;
            });

            container.innerHTML = '';
            container.className = viewMode === 'grid' ? 'file-grid' : 'file-list';

            if (viewMode === 'grid') {
                renderGridView(pane, sortedFiles, container, state);
            } else {
                renderListView(pane, sortedFiles, container, state);
            }

            // Update arrow button states
            updateArrowButtons();
        }

        function renderGridView(pane, files, container, state) {
            // Add parent directory if not at root
            if (state.path !== '/') {
                const parentDiv = createFileElement({
                    Name: '..',
                    IsDir: true
                }, -1, pane);
                container.appendChild(parentDiv);
            }

            files.forEach((file) => {
                const fileDiv = createFileElement(file, file._originalIndex, pane);
                container.appendChild(fileDiv);
            });
        }

        function renderListView(pane, files, container, state) {
            const table = document.createElement('table');

            // Create table header with sortable columns
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            const headers = [
                { label: 'Name', field: 'name', className: 'col-name' },
                { label: 'Size', field: 'size', className: 'col-size' },
                { label: 'Date', field: 'date', className: 'col-date' }
            ];

            headers.forEach((h, idx) => {
                const th = document.createElement('th');
                th.className = h.className;
                th.textContent = h.label;
                if (state.sortBy === h.field) {
                    const indicator = document.createElement('span');
                    indicator.className = 'sort-indicator';
                    indicator.textContent = state.sortAsc ? '‚ñ≤' : '‚ñº';
                    th.appendChild(indicator);
                }
                th.onclick = (e) => {
                    // Don't sort if clicking on resize handle
                    if (!e.target.classList.contains('resize-handle')) {
                        setSortBy(pane, h.field);
                    }
                };

                // Add resize handle (except for last column)
                if (idx < headers.length - 1) {
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.addEventListener('mousedown', (e) => startColumnResize(e, th));
                    th.appendChild(resizeHandle);
                }

                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');

            // Add parent directory if not at root
            if (state.path !== '/') {
                const tr = createListRow({ Name: '..', IsDir: true }, -1, pane);
                tbody.appendChild(tr);
            }

            files.forEach((file) => {
                const tr = createListRow(file, file._originalIndex, pane);
                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            container.appendChild(table);
        }

        // Create file element
        function createFileElement(file, index, pane) {
            const div = document.createElement('div');
            div.className = 'file-item';
            
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            if (index >= 0 && state.selectedIndexes.includes(index)) {
                div.classList.add('selected');
            }
            
            const icon = file.IsDir ? 'üìÅ' : 'üìÑ';
            div.innerHTML = `
                <div class="file-icon">${icon}</div>
                <div class="file-name">${file.Name}</div>
            `;

            // Double-click to navigate
            div.addEventListener('dblclick', () => {
                if (file.Name === '..') {
                    navigateUp(pane);
                } else if (file.IsDir) {
                    navigateInto(pane, file.Name);
                }
            });
            
            // Single click for selection
            if (index >= 0) {
                div.addEventListener('click', (e) => {
                    handleFileClick(pane, index, e);
                });

                // Draggable - handle mousedown for immediate selection before drag
                div.draggable = true;
                div.addEventListener('mousedown', (e) => {
                    // Only handle left mouse button without modifier keys
                    // If Ctrl/Cmd/Shift are pressed, let the click handler deal with multi-selection
                    if (e.button === 0 && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
                        // Select file immediately if not already selected
                        // This ensures visual feedback before drag starts
                        if (!state.selectedIndexes.includes(index)) {
                            console.log(`mousedown: Auto-selecting file ${index} before drag`);

                            // Clear opposite pane selection
                            const oppositeState = pane === 'left' ? rightPaneState : leftPaneState;
                            const oppositePane = pane === 'left' ? 'right' : 'left';
                            if (oppositeState.selectedIndexes.length > 0) {
                                oppositeState.selectedIndexes = [];
                                const oppositeContainer = document.getElementById(oppositePane === 'left' ? 'left-files' : 'right-files');
                                oppositeContainer.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            }

                            // Update state
                            state.selectedIndexes = [index];
                            // Update DOM directly without re-rendering to avoid interrupting drag
                            const container = document.getElementById(pane === 'left' ? 'left-files' : 'right-files');
                            container.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            div.classList.add('selected');
                        }
                    }
                });
                div.addEventListener('dragstart', (e) => {
                    handleDragStart(e, pane, index);
                });

                // Right-click context menu
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!state.selectedIndexes.includes(index)) {
                        state.selectedIndexes = [index];
                        renderFiles(pane);
                    }
                    showContextMenu(e, pane);
                });
            } else {
                // For ".." parent directory, add context menu without selection
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Clear selection for ".." - it's not a selectable item
                    state.selectedIndexes = [];
                    renderFiles(pane);
                    showContextMenu(e, pane);
                });
            }
            
            return div;
        }

        // Create list row (for list view)
        function createListRow(file, index, pane) {
            const tr = document.createElement('tr');
            tr.className = 'file-row';

            const state = pane === 'left' ? leftPaneState : rightPaneState;
            if (index >= 0 && state.selectedIndexes.includes(index)) {
                tr.classList.add('selected');
            }

            const icon = file.IsDir ? 'üìÅ' : 'üìÑ';

            // Name column
            const nameCell = document.createElement('td');
            nameCell.className = 'file-name-col';
            nameCell.innerHTML = `
                <span class="file-icon-small">${icon}</span>
                <span>${file.Name}</span>
            `;
            tr.appendChild(nameCell);

            // Size column
            const sizeCell = document.createElement('td');
            sizeCell.className = 'file-size-col';
            sizeCell.textContent = file.IsDir ? '' : formatFileSize(file.Size);
            tr.appendChild(sizeCell);

            // Date column
            const dateCell = document.createElement('td');
            dateCell.className = 'file-date-col';
            dateCell.textContent = formatFileDate(file.ModTime);
            tr.appendChild(dateCell);

            // Double-click to navigate
            tr.addEventListener('dblclick', () => {
                if (file.Name === '..') {
                    navigateUp(pane);
                } else if (file.IsDir) {
                    navigateInto(pane, file.Name);
                }
            });

            // Single click for selection
            if (index >= 0) {
                tr.addEventListener('click', (e) => {
                    handleFileClick(pane, index, e);
                });

                // Draggable - handle mousedown for immediate selection before drag
                tr.draggable = true;
                tr.addEventListener('mousedown', (e) => {
                    // Only handle left mouse button without modifier keys
                    // If Ctrl/Cmd/Shift are pressed, let the click handler deal with multi-selection
                    if (e.button === 0 && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
                        // Select file immediately if not already selected
                        // This ensures visual feedback before drag starts
                        if (!state.selectedIndexes.includes(index)) {
                            console.log(`mousedown: Auto-selecting file ${index} before drag`);

                            // Clear opposite pane selection
                            const oppositeState = pane === 'left' ? rightPaneState : leftPaneState;
                            const oppositePane = pane === 'left' ? 'right' : 'left';
                            if (oppositeState.selectedIndexes.length > 0) {
                                oppositeState.selectedIndexes = [];
                                const oppositeContainer = document.getElementById(oppositePane === 'left' ? 'left-files' : 'right-files');
                                oppositeContainer.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            }

                            // Update state
                            state.selectedIndexes = [index];
                            // Update DOM directly without re-rendering to avoid interrupting drag
                            const container = document.getElementById(pane === 'left' ? 'left-files' : 'right-files');
                            container.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                            tr.classList.add('selected');
                        }
                    }
                });
                tr.addEventListener('dragstart', (e) => {
                    handleDragStart(e, pane, index);
                });

                // Right-click context menu
                tr.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (!state.selectedIndexes.includes(index)) {
                        state.selectedIndexes = [index];
                        renderFiles(pane);
                    }
                    showContextMenu(e, pane);
                });
            } else {
                // For ".." parent directory, add context menu without selection
                tr.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    // Clear selection for ".." - it's not a selectable item
                    state.selectedIndexes = [];
                    renderFiles(pane);
                    showContextMenu(e, pane);
                });
            }

            return tr;
        }

        // Navigate up
        async function navigateUp(pane) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            let newPath;

            // Handle tilde paths specially
            if (state.path.startsWith('~/')) {
                if (state.path === '~/' || state.path === '~') {
                    // Already at home, can't go up
                    return;
                }
                // Remove tilde prefix, process, then add it back
                const pathWithoutTilde = state.path.substring(2); // Remove '~/'
                const pathParts = pathWithoutTilde.split('/').filter(p => p);
                pathParts.pop();
                if (pathParts.length === 0) {
                    newPath = '~/';
                } else {
                    newPath = '~/' + pathParts.join('/');
                }
            } else {
                // Regular path handling
                const pathParts = state.path.split('/').filter(p => p);
                pathParts.pop();
                newPath = '/' + pathParts.join('/');
            }

            // Save old path in case navigation fails
            const oldPath = state.path;
            state.path = newPath;
            document.getElementById(`${pane}-path`).value = newPath;

            try {
                await refreshPane(pane);
            } catch (error) {
                // Revert to old path if navigation failed
                state.path = oldPath;
                document.getElementById(`${pane}-path`).value = oldPath;
            }
        }

        // Navigate into directory
        async function navigateInto(pane, dirname) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const oldPath = state.path;
            const newPath = state.path.endsWith('/') ? state.path + dirname : state.path + '/' + dirname;

            state.path = newPath;
            document.getElementById(`${pane}-path`).value = newPath;

            try {
                await refreshPane(pane);
            } catch (error) {
                // Revert to old path if navigation failed
                state.path = oldPath;
                document.getElementById(`${pane}-path`).value = oldPath;
            }
        }

        // File selection
        function handleFileClick(pane, index, event) {
            lastFocusedPane = pane;  // Track which pane was clicked
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const oppositeState = pane === 'left' ? rightPaneState : leftPaneState;
            const oppositePane = pane === 'left' ? 'right' : 'left';
            let selectionChanged = false;
            let oppositeChanged = false;

            // Clear selection on opposite pane
            if (oppositeState.selectedIndexes.length > 0) {
                oppositeState.selectedIndexes = [];
                oppositeChanged = true;
            }

            if (event.ctrlKey || event.metaKey) {
                // Toggle selection
                const idx = state.selectedIndexes.indexOf(index);
                if (idx >= 0) {
                    state.selectedIndexes.splice(idx, 1);
                } else {
                    state.selectedIndexes.push(index);
                }
                selectionChanged = true;
            } else if (event.shiftKey && state.selectedIndexes.length > 0) {
                // Range selection from last selected to current
                // Use visual order (sorted) not array order
                const lastIndex = state.selectedIndexes[state.selectedIndexes.length - 1];
                const lastVisual = state.visualOrder[lastIndex] ?? lastIndex;
                const currentVisual = state.visualOrder[index] ?? index;
                const visualStart = Math.min(lastVisual, currentVisual);
                const visualEnd = Math.max(lastVisual, currentVisual);

                // Convert visual positions back to original indexes
                state.selectedIndexes = [];
                Object.keys(state.visualOrder).forEach(origIndex => {
                    const visualPos = state.visualOrder[origIndex];
                    if (visualPos >= visualStart && visualPos <= visualEnd) {
                        state.selectedIndexes.push(parseInt(origIndex));
                    }
                });
                selectionChanged = true;
            } else {
                // Single selection - only change if different
                if (state.selectedIndexes.length !== 1 || state.selectedIndexes[0] !== index) {
                    state.selectedIndexes = [index];
                    selectionChanged = true;
                }
            }

            // Re-render panes if selection changed
            if (selectionChanged) {
                renderFiles(pane);
            }
            if (oppositeChanged) {
                renderFiles(oppositePane);
            }
        }

        // Drag and drop
        function handleDragStart(event, pane, index) {
            const state = pane === 'left' ? leftPaneState : rightPaneState;

            console.log(`handleDragStart: pane=${pane}, index=${index}, selected=${JSON.stringify(state.selectedIndexes)}`);

            // Note: Selection already happened in mousedown handler
            // This ensures the file is visually selected before drag starts

            event.dataTransfer.effectAllowed = 'copy';
            event.dataTransfer.setData('text/plain', JSON.stringify({
                pane,
                indexes: state.selectedIndexes
            }));
        }

        function handleDragOver(event, targetPane) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            document.getElementById(`${targetPane}-files`).classList.add('drag-over');
        }

        function handleDragLeave(event, targetPane) {
            document.getElementById(`${targetPane}-files`).classList.remove('drag-over');
        }

        async function handleDrop(event, targetPane) {
            event.preventDefault();
            document.getElementById(`${targetPane}-files`).classList.remove('drag-over');

            const data = JSON.parse(event.dataTransfer.getData('text/plain'));
            const sourcePane = data.pane;

            if (sourcePane === targetPane) {
                return; // Can't drop on same pane
            }

            const sourceState = sourcePane === 'left' ? leftPaneState : rightPaneState;
            const targetState = targetPane === 'left' ? leftPaneState : rightPaneState;

            // Build file list and paths for confirmation dialog
            const files = data.indexes.map(index => sourceState.files[index]);
            const fileNames = files.map(f => f.Name);

            // Build source and destination paths
            const sourcePath = sourceState.remote ?
                `${sourceState.remote}:${sourceState.path}` :
                sourceState.path;
            const destPath = targetState.remote ?
                `${targetState.remote}:${targetState.path}` :
                targetState.path;

            // Store the pending operation
            pendingDragDrop = {
                sourcePane,
                targetPane,
                sourceState,
                targetState,
                indexes: data.indexes,
                files
            };

            // Show confirmation dialog
            showDragDropConfirmModal(fileNames, sourcePath, destPath);
        }

        function showDragDropConfirmModal(fileNames, sourcePath, destPath) {
            // Populate file list
            const fileListHtml = fileNames.map(name => `‚Ä¢ ${name}`).join('<br>');
            document.getElementById('drag-drop-file-list').innerHTML = fileListHtml;

            // Show source and destination
            document.getElementById('drag-drop-source').textContent = sourcePath;
            document.getElementById('drag-drop-destination').textContent = destPath;

            // Show modal
            document.getElementById('drag-drop-confirm-modal').style.display = 'flex';
        }

        function closeDragDropConfirmModal() {
            document.getElementById('drag-drop-confirm-modal').style.display = 'none';
            pendingDragDrop = null;
        }

        async function confirmDragDrop() {
            if (!pendingDragDrop) return;

            const { sourceState, targetState, targetPane, indexes } = pendingDragDrop;

            // Close modal
            closeDragDropConfirmModal();

            // Start copy jobs for each selected file
            for (const index of indexes) {
                const file = sourceState.files[index];
                const srcPath = sourceState.remote ?
                    `${sourceState.remote}:${buildPath(sourceState.path, file.Name)}` :
                    buildPath(sourceState.path, file.Name);
                // Destination with trailing slash (rsync semantics: copy into directory)
                const dstPath = targetState.remote ?
                    `${targetState.remote}:${targetState.path}/` :
                    `${targetState.path}/`;

                try {
                    await apiCall('/api/jobs/copy', 'POST', {
                        src_path: srcPath,
                        dst_path: dstPath,
                        copy_links: false
                    });
                } catch (error) {
                    console.error('Copy failed:', error);
                    alert(`Failed to copy ${file.Name}: ${error.message}`);
                }
            }

            // Refresh target pane and update jobs
            refreshPane(targetPane);
            updateJobs();
        }

        // Context menu
        function showContextMenu(event, pane) {
            lastFocusedPane = pane;  // Track which pane has context menu
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            contextMenuState.pane = pane;
            contextMenuState.items = state.selectedIndexes.map(i => state.files[i]);

            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';

            // Get menu items
            const menuItems = menu.querySelectorAll('.context-menu-item');
            const createFolderItem = menuItems[0];  // üìÅ Create Folder
            const renameItem = menuItems[1];  // ‚úèÔ∏è Rename
            const deleteItem = menuItems[2];  // üóëÔ∏è Delete

            // Show/hide items based on selection
            const hasSelection = state.selectedIndexes.length > 0;
            const isSingleSelection = state.selectedIndexes.length === 1;

            // Create Folder: always available
            createFolderItem.style.display = 'block';

            // Rename: only for single selection
            if (isSingleSelection) {
                renameItem.style.display = 'block';
            } else {
                renameItem.style.display = 'none';
            }

            // Delete: only when something is selected
            if (hasSelection) {
                deleteItem.style.display = 'block';
            } else {
                deleteItem.style.display = 'none';
            }
        }

        function contextMenuAction(action) {
            document.getElementById('context-menu').style.display = 'none';

            if (action === 'rename' && contextMenuState.items.length === 1) {
                showRenameModal(contextMenuState.items[0].Name);
            } else if (action === 'delete') {
                showDeleteConfirmModal();
            } else if (action === 'newfolder') {
                createFolder(contextMenuState.pane);
            }
        }

        function contextMenuSortBy(field, ascending) {
            document.getElementById('context-menu').style.display = 'none';

            const pane = contextMenuState.pane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            state.sortBy = field;
            state.sortAsc = ascending;
            renderFiles(pane);
        }

        // Rename modal
        function showRenameModal(currentName) {
            const input = document.getElementById('rename-input');
            input.value = currentName;
            document.getElementById('rename-modal').style.display = 'flex';
            // Focus and select text for easy editing
            setTimeout(() => {
                input.focus();
                input.select();
            }, 0);
        }

        function closeRenameModal() {
            document.getElementById('rename-modal').style.display = 'none';
        }

        async function confirmRename() {
            const newName = document.getElementById('rename-input').value.trim();
            if (!newName) {
                alert('Please enter a name');
                return;
            }

            const pane = contextMenuState.pane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;
            const file = contextMenuState.items[0];

            // Skip no-op rename (same name)
            if (newName === file.Name) {
                closeRenameModal();
                return;
            }

            // Check if destination already exists
            const existingFile = state.files.find(f => f.Name === newName);
            if (existingFile) {
                alert(`A file or folder named "${newName}" already exists in this directory`);
                return;
            }

            const oldPath = state.remote ?
                `${state.remote}:${buildPath(state.path, file.Name)}` :
                buildPath(state.path, file.Name);
            const newPath = state.remote ?
                `${state.remote}:${buildPath(state.path, newName)}` :
                buildPath(state.path, newName);

            try {
                // Use move operation for rename
                await apiCall('/api/jobs/move', 'POST', {
                    src_path: oldPath,
                    dst_path: newPath
                });
                closeRenameModal();
                refreshPane(pane);
            } catch (error) {
                alert(`Rename failed: ${error.message}`);
            }
        }

        // Delete confirmation
        function showDeleteConfirmModal() {
            const count = contextMenuState.items.length;
            document.getElementById('delete-confirm-message').textContent = 
                `Are you sure you want to delete ${count} item(s)?`;
            document.getElementById('delete-confirm-modal').style.display = 'flex';
        }

        function closeDeleteConfirmModal() {
            document.getElementById('delete-confirm-modal').style.display = 'none';
        }

        async function confirmDelete() {
            const pane = contextMenuState.pane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;

            // Close modal immediately for better UX
            closeDeleteConfirmModal();

            // Perform deletes in background
            for (const file of contextMenuState.items) {
                const path = state.remote ?
                    `${state.remote}:${buildPath(state.path, file.Name)}` :
                    buildPath(state.path, file.Name);

                try {
                    await apiCall('/api/files/delete', 'POST', { path });
                } catch (error) {
                    alert(`Failed to delete ${file.Name}: ${error.message}`);
                }
            }

            // Refresh after all deletes complete
            refreshPane(pane, true);
        }

        // Create folder
        function createFolder(pane) {
            createFolderPane = pane;
            const input = document.getElementById('create-folder-input');
            input.value = '';
            document.getElementById('create-folder-modal').style.display = 'flex';
            // Focus input for immediate typing
            setTimeout(() => {
                input.focus();
            }, 0);
        }

        function closeCreateFolderModal() {
            document.getElementById('create-folder-modal').style.display = 'none';
        }

        async function confirmCreateFolder() {
            let name = document.getElementById('create-folder-input').value.trim();
            if (!name) {
                alert('Please enter a folder name');
                return;
            }

            const pane = createFolderPane;
            const state = pane === 'left' ? leftPaneState : rightPaneState;

            // Support relative paths - resolve against current directory
            const resolvedName = resolveRelativePath(state.path, name);

            const path = state.remote ?
                `${state.remote}:${resolvedName}` :
                resolvedName;

            try {
                await apiCall('/api/files/mkdir', 'POST', { path: expandTildePath(path) });
                closeCreateFolderModal();
                refreshPane(pane);
            } catch (error) {
                alert(`Failed to create folder: ${error.message}`);
            }
        }

        // Manage Remotes Dialog
        let manageRemotesState = {
            remotes: [],
            templates: [],
            selectedTemplate: null,
            formValues: {}
        };

        async function openManageRemotesDialog() {
            document.getElementById('manage-remotes-modal').style.display = 'flex';
            showRemotesList();
            await loadRemotesList();
            await loadTemplatesList();

            // Add Enter key handler for the template selection step
            document.addEventListener('keydown', handleManageRemotesKeydown);
        }

        function closeManageRemotesDialog() {
            document.getElementById('manage-remotes-modal').style.display = 'none';
            manageRemotesState.selectedTemplate = null;
            manageRemotesState.formValues = {};

            // Remove Enter key handler
            document.removeEventListener('keydown', handleManageRemotesKeydown);
        }

        function handleManageRemotesKeydown(event) {
            // Check which step is visible
            const step1 = document.getElementById('manage-remotes-step1');
            const step2 = document.getElementById('manage-remotes-step2');
            const step3 = document.getElementById('manage-remotes-step3');

            if (event.key === 'Escape') {
                event.preventDefault();
                // If on wizard steps 2 or 3, return to remotes list
                if (step2.style.display !== 'none' || step3.style.display !== 'none') {
                    showRemotesList();
                } else {
                    // Otherwise close the entire dialog
                    closeManageRemotesDialog();
                }
            } else if (event.key === 'Enter') {
                if (step2.style.display !== 'none') {
                    // In template selection step - trigger Next button
                    const nextBtn = document.getElementById('template-next-btn');
                    if (!nextBtn.disabled) {
                        event.preventDefault();
                        showRemoteForm();
                    }
                } else if (step3.style.display !== 'none') {
                    // In remote form step - trigger Create Remote button
                    const createBtn = document.getElementById('create-remote-btn');
                    if (createBtn && !createBtn.disabled) {
                        event.preventDefault();
                        createRemote();
                    }
                }
            }
        }

        function showRemotesList() {
            document.getElementById('manage-remotes-step1').style.display = 'flex';
            document.getElementById('manage-remotes-step2').style.display = 'none';
            document.getElementById('manage-remotes-step3').style.display = 'none';
        }

        function showTemplateSelection() {
            document.getElementById('manage-remotes-step1').style.display = 'none';
            document.getElementById('manage-remotes-step2').style.display = 'flex';
            document.getElementById('manage-remotes-step3').style.display = 'none';
            document.getElementById('template-next-btn').disabled = !manageRemotesState.selectedTemplate;
        }

        function showRemoteForm() {
            document.getElementById('manage-remotes-step1').style.display = 'none';
            document.getElementById('manage-remotes-step2').style.display = 'none';
            document.getElementById('manage-remotes-step3').style.display = 'flex';
            generateRemoteForm();
        }

        async function loadRemotesList() {
            try {
                const data = await apiCall('/api/remotes');
                manageRemotesState.remotes = data.remotes || [];
                renderRemotesList();
            } catch (error) {
                document.getElementById('remotes-list-container').innerHTML =
                    `<p style="color: #dc3545;">Error loading remotes: ${error.message}</p>`;
            }
        }

        async function loadTemplatesList() {
            try {
                const data = await apiCall('/api/templates');
                manageRemotesState.templates = data.templates || [];

                // Show/hide Add Remote button based on template availability
                const addBtn = document.getElementById('add-remote-btn');
                if (data.available && data.templates.length > 0) {
                    addBtn.style.display = 'inline-block';
                } else {
                    addBtn.style.display = 'none';
                }

                renderTemplatesList();
            } catch (error) {
                console.error('Error loading templates:', error);
                document.getElementById('add-remote-btn').style.display = 'none';
            }
        }

        function renderRemotesList() {
            const container = document.getElementById('remotes-list-container');

            if (manageRemotesState.remotes.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center;">No remotes configured</p>';
                return;
            }

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="border-bottom: 2px solid #ddd;">';
            html += '<th style="text-align: left; padding: 8px;">Name</th>';
            html += '<th style="text-align: left; padding: 8px;">Type</th>';
            html += '<th style="text-align: center; padding: 8px; width: 100px;">Actions</th>';
            html += '</tr></thead><tbody>';

            manageRemotesState.remotes.forEach(remote => {
                html += '<tr style="border-bottom: 1px solid #eee; cursor: pointer; transition: background-color 0.2s;" onclick="viewRemoteConfig(\'' + remote.name + '\')" title="Click to view configuration" onmouseover="this.style.backgroundColor=\'#f0f8ff\'" onmouseout="this.style.backgroundColor=\'white\'">';
                html += `<td style="padding: 8px;">${remote.name}</td>`;
                html += `<td style="padding: 8px;">${remote.type}</td>`;
                html += `<td style="padding: 8px; text-align: center;" onclick="event.stopPropagation()">`;
                // Edit icon (gear)
                html += `<button onclick="editRemoteConfig('${remote.name}')" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #007bff; padding: 4px 8px; margin-right: 4px;" title="Edit remote">‚öôÔ∏è</button>`;
                // Delete icon (red X)
                html += `<button onclick="deleteRemote('${remote.name}')" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #dc3545; padding: 4px 8px;" title="Delete remote">√ó</button>`;
                html += '</td></tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function viewRemoteConfig(remoteName) {
            const remote = manageRemotesState.remotes.find(r => r.name === remoteName);
            if (!remote) return;

            // Store remote config for copying
            manageRemotesState.currentViewedRemote = remote;

            const container = document.getElementById('remote-config-content');

            let html = `<h4 style="margin-top: 0; margin-bottom: 15px; color: #333;">${remote.name}</h4>`;
            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border: 1px solid #dee2e6;">';
            html += '<table style="width: 100%; border-collapse: collapse;">';

            const configEntries = Object.entries(remote.config);
            const lastIndex = configEntries.length - 1;

            configEntries.forEach(([key, value], index) => {
                // Mask sensitive values
                const isSensitive = key.toLowerCase().includes('password') ||
                                   key.toLowerCase().includes('secret') ||
                                   key.toLowerCase().includes('key') ||
                                   key.toLowerCase().includes('token');
                const displayValue = isSensitive ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : value;

                // Only add border-bottom if not the last item
                const borderStyle = index !== lastIndex ? 'border-bottom: 1px solid #e0e0e0;' : '';
                html += `<tr style="${borderStyle}">`;
                html += `<td style="padding: 8px; font-weight: 500; color: #495057; width: 40%;">${key}</td>`;
                html += `<td style="padding: 8px; color: #212529; font-family: monospace; word-break: break-all;">${displayValue}</td>`;
                html += '</tr>';
            });

            html += '</table></div>';
            container.innerHTML = html;

            document.getElementById('view-remote-config-modal').style.display = 'flex';

            // Add Ctrl-C listener
            document.addEventListener('keydown', handleViewRemoteConfigKeydown);
        }

        function closeViewRemoteConfigModal() {
            document.getElementById('view-remote-config-modal').style.display = 'none';

            // Remove Ctrl-C listener
            document.removeEventListener('keydown', handleViewRemoteConfigKeydown);
        }

        function handleViewRemoteConfigKeydown(event) {
            // Check for Ctrl-C or Cmd-C (Mac)
            if ((event.ctrlKey || event.metaKey) && event.key === 'c') {
                // Only trigger if the modal is actually visible
                const modal = document.getElementById('view-remote-config-modal');
                if (modal.style.display === 'flex') {
                    // Don't prevent default if user is selecting text to copy normally
                    const selection = window.getSelection();
                    if (!selection || selection.toString().length === 0) {
                        event.preventDefault();
                        copyRemoteConfigToClipboard();
                    }
                }
            }
        }

        async function copyRemoteConfigToClipboard() {
            const remoteName = manageRemotesState.currentViewedRemote?.name;
            if (!remoteName) return;

            try {
                // Get raw config from API
                const data = await apiCall(`/api/remotes/${encodeURIComponent(remoteName)}/raw`);
                const configText = data.raw_config;

                await navigator.clipboard.writeText(configText);

                // Show tooltip
                const tooltip = document.getElementById('copy-tooltip');
                tooltip.style.display = 'inline';

                // Hide after 1 second
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 1000);
            } catch (error) {
                console.error('Failed to copy to clipboard:', error);
                alert('Failed to copy to clipboard');
            }
        }

        // Edit Remote Config
        async function editRemoteConfig(remoteName) {
            try {
                // Get raw config from API (includes comments)
                const data = await apiCall(`/api/remotes/${encodeURIComponent(remoteName)}/raw`);

                // Store the original remote name
                manageRemotesState.editingRemote = {
                    originalName: remoteName
                };

                // Populate the textarea (no trailing newline)
                document.getElementById('edit-remote-config-text').value = data.raw_config;

                // Show the modal
                document.getElementById('edit-remote-config-modal').style.display = 'flex';
            } catch (error) {
                console.error('Error loading remote config:', error);
                alert(`Failed to load remote config: ${error.message}`);
            }
        }

        function closeEditRemoteConfigModal() {
            document.getElementById('edit-remote-config-modal').style.display = 'none';
            manageRemotesState.editingRemote = null;
        }

        async function saveRemoteConfig() {
            if (!manageRemotesState.editingRemote) return;

            const configText = document.getElementById('edit-remote-config-text').value;
            const originalName = manageRemotesState.editingRemote.originalName;

            try {
                // Use the new raw API to update in-place
                const data = await apiCall(`/api/remotes/${encodeURIComponent(originalName)}/raw`, 'PUT', {
                    raw_config: configText
                });

                const newName = data.new_name;
                const isRename = newName !== originalName;

                // Close modal and refresh
                closeEditRemoteConfigModal();
                await loadRemotesList();
                await refreshPane('left');
                await refreshPane('right');

                alert(isRename ?
                    `Remote successfully renamed from "${originalName}" to "${newName}"` :
                    `Remote "${newName}" updated successfully`);

            } catch (error) {
                console.error('Error saving remote:', error);
                alert(`Failed to save remote: ${error.message}`);
            }
        }

        function renderTemplatesList() {
            const container = document.getElementById('templates-list-container');

            if (manageRemotesState.templates.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center;">No templates available</p>';
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';

            manageRemotesState.templates.forEach(template => {
                const isSelected = manageRemotesState.selectedTemplate?.name === template.name;
                const selectedStyle = isSelected ? 'border: 2px solid #007bff; background: #e7f3ff;' : 'border: 1px solid #ddd;';

                html += `<div onclick="selectTemplate('${template.name}')" style="padding: 12px; ${selectedStyle} border-radius: 6px; cursor: pointer;">`;
                html += `<strong style="display: block; margin-bottom: 4px;">${template.name}</strong>`;
                html += `<small style="color: #666;">Fields: ${template.fields.map(f => f.label).join(', ')}</small>`;
                html += '</div>';
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function selectTemplate(templateName) {
            const template = manageRemotesState.templates.find(t => t.name === templateName);
            manageRemotesState.selectedTemplate = template;
            renderTemplatesList();
            document.getElementById('template-next-btn').disabled = false;
        }

        function generateRemoteForm() {
            const container = document.getElementById('remote-form-container');
            const template = manageRemotesState.selectedTemplate;

            if (!template) return;

            let html = `<p style="margin-bottom: 15px;"><strong>Template:</strong> ${template.name}</p>`;
            html += '<div style="display: flex; flex-direction: column; gap: 12px;">';

            // Remote Name field
            html += '<div>';
            html += '<label style="display: block; margin-bottom: 4px; font-weight: 500;">Remote Name</label>';
            html += '<input type="text" id="remote-name-input" placeholder="Enter remote name" ';
            html += 'pattern="[a-zA-Z0-9_-]+" title="Use only letters, numbers, underscores, and hyphens" ';
            html += 'style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" required />';
            html += '<small style="color: #666;">Use only letters, numbers, underscores, and hyphens</small>';
            html += '</div>';

            // Template fields
            template.fields.forEach(field => {
                const isSecret = field.label.toLowerCase().includes('password') ||
                                field.label.toLowerCase().includes('secret') ||
                                field.label.toLowerCase().includes('key');
                const inputType = isSecret ? 'password' : 'text';

                html += '<div>';
                html += `<label style="display: block; margin-bottom: 4px; font-weight: 500;">${field.label}</label>`;
                html += `<input type="${inputType}" id="field-${field.key}" placeholder="Enter ${field.label}" `;
                html += 'style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" required />';
                html += '</div>';
            });

            html += '</div>';
            container.innerHTML = html;

            // Add event listeners for validation
            setTimeout(() => {
                validateRemoteForm(); // Initial validation - button should be disabled

                // Add input listeners to all fields
                document.getElementById('remote-name-input').addEventListener('input', validateRemoteForm);
                template.fields.forEach(field => {
                    document.getElementById(`field-${field.key}`).addEventListener('input', validateRemoteForm);
                });
            }, 0);
        }

        function validateRemoteForm() {
            const template = manageRemotesState.selectedTemplate;
            if (!template) return;

            const createBtn = document.getElementById('create-remote-btn');
            if (!createBtn) return;

            // Check remote name
            const remoteName = document.getElementById('remote-name-input')?.value.trim();
            if (!remoteName) {
                createBtn.disabled = true;
                return;
            }

            // Check all template fields
            for (const field of template.fields) {
                const input = document.getElementById(`field-${field.key}`);
                if (!input || !input.value.trim()) {
                    createBtn.disabled = true;
                    return;
                }
            }

            // All fields are filled
            createBtn.disabled = false;
        }

        async function deleteRemote(remoteName) {
            if (!confirm(`Are you sure you want to delete the remote "${remoteName}"?`)) {
                return;
            }

            try {
                await apiCall(`/api/remotes/${remoteName}`, 'DELETE');
                await loadRemotesList();

                // Reload remote dropdowns
                await loadRemotes();
            } catch (error) {
                alert(`Failed to delete remote: ${error.message}`);
            }
        }

        async function createRemote() {
            const remoteName = document.getElementById('remote-name-input').value.trim();
            const template = manageRemotesState.selectedTemplate;

            if (!remoteName) {
                alert('Please enter a remote name');
                return;
            }

            if (!/^[a-zA-Z0-9_-]+$/.test(remoteName)) {
                alert('Invalid remote name. Use only letters, numbers, underscores, and hyphens.');
                return;
            }

            // Collect field values
            const values = {};
            for (const field of template.fields) {
                const input = document.getElementById(`field-${field.key}`);
                if (!input || !input.value.trim()) {
                    alert(`Please fill in all fields: ${field.label}`);
                    return;
                }
                values[field.label] = input.value.trim();
            }

            try {
                const createBtn = document.getElementById('create-remote-btn');
                createBtn.disabled = true;
                createBtn.textContent = 'Creating...';

                await apiCall('/api/remotes', 'POST', {
                    name: remoteName,
                    template: template.name,
                    values: values
                });

                // Reload remotes list and dropdowns
                await loadRemotesList();
                await loadRemotes();

                // Go back to step 1
                showRemotesList();

                createBtn.disabled = false;
                createBtn.textContent = 'Create Remote';

            } catch (error) {
                alert(`Failed to create remote: ${error.message}`);
                const createBtn = document.getElementById('create-remote-btn');
                createBtn.disabled = false;
                createBtn.textContent = 'Create Remote';
            }
        }

        // Job panel
        function toggleJobPanel() {
            const panel = document.getElementById('job-panel');
            panel.classList.toggle('collapsed');
            // Mark that user manually toggled the panel
            jobPanelManuallyToggled = !panel.classList.contains('collapsed');
        }

        function startJobUpdates() {
            updateJobs();
            jobUpdateInterval = setInterval(updateJobs, 2000);
        }

        async function updateJobs() {
            try {
                const data = await apiCall('/api/jobs?status=running');
                const oldCount = jobsData.jobs.length;
                const previousJobs = new Set(jobsData.jobs.map(j => j.job_id));
                jobsData.jobs = data.jobs || [];
                const newCount = jobsData.jobs.length;
                const currentJobs = new Set(jobsData.jobs.map(j => j.job_id));

                // Detect completed jobs (were tracked, now not in running list)
                const completedJobs = [...trackedJobs].filter(id => !currentJobs.has(id));

                // Auto-refresh destination pane for completed jobs
                for (const jobId of completedJobs) {
                    // Fetch job details to get destination path
                    try {
                        const jobDetails = await apiCall(`/api/jobs/${jobId}`);
                        if (jobDetails && jobDetails.status === 'completed') {
                            // Determine which pane to refresh based on destination
                            const dstPath = jobDetails.dst_path;

                            // Check if destination matches either pane
                            let refreshLeft = false;
                            let refreshRight = false;

                            if (dstPath.includes(':')) {
                                // Remote path
                                const [remote, path] = dstPath.split(':', 2);
                                if (leftPaneState.remote === remote && path.startsWith(leftPaneState.path)) {
                                    refreshLeft = true;
                                }
                                if (rightPaneState.remote === remote && path.startsWith(rightPaneState.path)) {
                                    refreshRight = true;
                                }
                            } else {
                                // Local path
                                if (!leftPaneState.remote && dstPath.startsWith(leftPaneState.path)) {
                                    refreshLeft = true;
                                }
                                if (!rightPaneState.remote && dstPath.startsWith(rightPaneState.path)) {
                                    refreshRight = true;
                                }
                            }

                            // Refresh destination pane(s) with selection preservation
                            if (refreshLeft) {
                                await refreshPane('left', true);
                            }
                            if (refreshRight) {
                                await refreshPane('right', true);
                            }
                        }
                    } catch (err) {
                        console.error(`Failed to auto-refresh after job ${jobId}:`, err);
                    }
                }

                // Update tracked jobs
                trackedJobs = currentJobs;

                // State-based auto-expand/collapse: only change on state transitions
                const panel = document.getElementById('job-panel');
                const isCollapsed = panel.classList.contains('collapsed');
                const currentState = newCount === 0 ? 'empty' : 'non-empty';

                // Only auto-open/close on state transitions (empty ‚Üî non-empty)
                if (!jobPanelManuallyToggled) {
                    // Transition from empty to non-empty: auto-open
                    if (previousJobState === 'empty' && currentState === 'non-empty') {
                        panel.classList.remove('collapsed');
                    }
                    // Transition from non-empty to empty: auto-close
                    else if (previousJobState === 'non-empty' && currentState === 'empty') {
                        panel.classList.add('collapsed');
                    }
                    // No state change: keep panel as is
                }

                previousJobState = currentState;
                renderJobs();
            } catch (error) {
                console.error('Failed to update jobs:', error);
            }
        }

        async function cancelJob(jobId) {
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                updateJobs();
            } catch (error) {
                alert(`Failed to cancel job: ${error.message}`);
            }
        }

        function renderJobs() {
            const container = document.getElementById('job-list');
            const count = document.getElementById('job-count');
            count.textContent = jobsData.jobs.length;

            if (jobsData.jobs.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #999;">No active jobs</p>';
                return;
            }

            // Helper function to format time as "1h23min22s" or "10min5s" or "10s"
            // No unnecessary zeros
            function formatTime(seconds) {
                // Ensure we have a valid positive number
                if (!seconds || seconds < 0) return '0s';

                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;

                if (hours > 0) {
                    return `${hours}h${minutes}min${secs}s`;
                } else if (minutes > 0) {
                    return `${minutes}min${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }

            // Helper function to parse transfer info from rclone text output
            // Text format: "Transferred (bytes):   123.45 MiB / 500 MiB, 25%, 10.5 MiB/s, ETA 35s"
            // or legacy: "Transferred:   123.45 MiB / 500 MiB, 25%, 10.5 MiB/s, ETA 35s"
            function parseTransferInfo(text) {
                if (!text) return null;

                // Look for "Transferred (bytes):" or "Transferred:" line with byte-based progress
                const transferMatch = text.match(/Transferred(?:\s+\(bytes\))?:\s+([0-9.]+)\s*([A-Za-z]+)\s*\/\s*([0-9.]+)\s*([A-Za-z]+).*?([0-9.]+)\s*([A-Za-z/]+)s.*?ETA\s+(.+?)$/m);
                if (transferMatch) {
                    const transferred = transferMatch[1];
                    const transferredUnit = transferMatch[2];
                    const total = transferMatch[3];
                    const totalUnit = transferMatch[4];
                    const speed = transferMatch[5];
                    const speedUnit = transferMatch[6];
                    const eta = transferMatch[7].trim();

                    return {
                        transferred: `${transferred} ${transferredUnit}`,
                        total: `${total} ${totalUnit}`,
                        speed: `${speed} ${speedUnit}/s`,
                        eta: eta
                    };
                }

                return null;
            }

            container.innerHTML = jobsData.jobs.map(job => {
                // Calculate elapsed time with proper timestamp parsing
                let elapsedSec = 0;
                try {
                    // SQLite CURRENT_TIMESTAMP returns UTC time as "YYYY-MM-DD HH:MM:SS"
                    // We need to tell JavaScript it's UTC by adding 'Z' suffix
                    const timestampStr = job.created_at;

                    let createdAt;
                    if (timestampStr.includes('T')) {
                        // Already ISO format, might have 'Z'
                        createdAt = new Date(timestampStr);
                    } else {
                        // SQLite format: "YYYY-MM-DD HH:MM:SS" (UTC)
                        // Convert to ISO format and add 'Z' to indicate UTC
                        createdAt = new Date(timestampStr.replace(' ', 'T') + 'Z');
                    }

                    const now = new Date();

                    // Validate the date is valid
                    if (!isNaN(createdAt.getTime())) {
                        elapsedSec = Math.floor((now - createdAt) / 1000);
                        // Sanity check: if elapsed time is negative or absurdly large, use 0
                        if (elapsedSec < 0 || elapsedSec > 86400 * 365) {
                            console.warn(`Job ${job.job_id}: Invalid elapsed time ${elapsedSec}s from timestamp ${timestampStr}`);
                            elapsedSec = 0;
                        }
                    } else {
                        console.error(`Job ${job.job_id}: Invalid timestamp ${timestampStr}`);
                    }
                } catch (e) {
                    console.error('Error parsing job timestamp:', job.created_at, e);
                    elapsedSec = 0;
                }

                const elapsedStr = formatTime(elapsedSec);

                // Parse transfer information from job text
                const transferInfo = parseTransferInfo(job.text);
                const progress = job.progress || 0;

                // Build transfer status string
                let transferStatus = '';
                if (transferInfo) {
                    // We have detailed transfer info from rclone
                    transferStatus = `${transferInfo.eta} left - ${transferInfo.transferred} out of ${transferInfo.total} (${transferInfo.speed})`;
                } else {
                    // Fallback: calculate ETA from progress or show progress percentage
                    if (progress >= 100) {
                        transferStatus = 'Done';
                    } else if (progress > 0) {
                        // Show calculated ETA if we have progress
                        if (elapsedSec > 1) {
                            const remainingPercent = 100 - progress;
                            const etaSec = Math.floor((elapsedSec / progress) * remainingPercent);
                            const etaStr = formatTime(etaSec);
                            transferStatus = `${etaStr} left (${progress}%)`;
                        } else {
                            transferStatus = `${progress}% - Starting...`;
                        }
                    } else {
                        // No progress yet
                        transferStatus = 'Starting...';
                    }
                }

                return `
                    <div class="job-item ${job.status}">
                        <span class="job-id">Job #${job.job_id} - ${job.operation}</span>
                        <span class="job-path">${job.src_path} ‚Üí ${job.dst_path} (${elapsedStr})</span>
                        <span class="job-time-info">${transferStatus}</span>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${progress}%">
                                ${progress}%
                            </div>
                        </div>
                        <span class="job-status">${job.status}</span>
                        <button class="job-icon-btn cancel" onclick="cancelJob(${job.job_id})" title="Cancel job">√ó</button>
                    </div>
                `;
            }).join('');
        }

        // Interrupted Jobs Dropdown
        function toggleInterruptedJobsDropdown() {
            const list = document.getElementById('interrupted-jobs-list');
            list.classList.toggle('hidden');
        }

        function startInterruptedJobsUpdates() {
            updateInterruptedJobs();
            interruptedJobsInterval = setInterval(updateInterruptedJobs, 5000);
        }

        async function updateInterruptedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=interrupted');
                interruptedJobsData.jobs = data.jobs || [];
                renderInterruptedJobs();
            } catch (error) {
                console.error('Failed to update interrupted jobs:', error);
            }
        }

        function renderInterruptedJobs() {
            const dropdown = document.getElementById('interrupted-jobs-dropdown');
            const list = document.getElementById('interrupted-jobs-list');
            const count = document.getElementById('interrupted-count');

            if (interruptedJobsData.jobs.length === 0) {
                dropdown.classList.add('hidden');
                return;
            }

            dropdown.classList.remove('hidden');
            count.textContent = interruptedJobsData.jobs.length;

            list.innerHTML = interruptedJobsData.jobs.map(job => `
                <div class="interrupted-job-item">
                    <div class="interrupted-job-info">
                        Job #${job.job_id}: ${job.src_path} ‚Üí ${job.dst_path}
                    </div>
                    <div class="interrupted-job-actions">
                        <button class="job-icon-btn resume" onclick="resumeInterruptedJobFromDropdown(${job.job_id})" title="Resume this job">‚ñ∂</button>
                        <button class="job-icon-btn cancel" onclick="cancelInterruptedJob(${job.job_id})" title="Cancel this job">√ó</button>
                    </div>
                </div>
            `).join('');
        }

        async function cancelInterruptedJob(jobId) {
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                updateInterruptedJobs();
            } catch (error) {
                alert(`Failed to cancel job: ${error.message}`);
            }
        }

        async function resumeInterruptedJobFromDropdown(jobId) {
            try {
                const data = await apiCall(`/api/jobs/${jobId}/resume`, 'POST');
                updateInterruptedJobs();
                updateJobs();  // Refresh active jobs too
            } catch (error) {
                alert(`Failed to resume job: ${error.message}`);
            }
        }

        // Interrupted jobs modal (startup)
        async function checkInterruptedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=resumable');
                if (data.jobs && data.jobs.length > 0) {
                    showInterruptedJobsModal(data.jobs);
                }
            } catch (error) {
                console.error('Failed to check interrupted jobs:', error);
            }
        }

        function showInterruptedJobsModal(jobs) {
            const list = document.getElementById('interrupted-jobs-list');
            list.innerHTML = jobs.map(job => `
                <div style="padding: 8px; background: #f8f9fa; margin: 5px 0; border-radius: 4px;">
                    Job #${job.job_id}: ${job.src_path} ‚Üí ${job.dst_path}
                </div>
            `).join('');
            document.getElementById('interrupted-jobs-modal').style.display = 'flex';
        }

        function closeInterruptedJobsModal() {
            document.getElementById('interrupted-jobs-modal').style.display = 'none';
        }

        async function resumeAllInterruptedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=resumable');
                for (const job of data.jobs) {
                    await apiCall(`/api/jobs/${job.job_id}/resume`, 'POST');
                }
                closeInterruptedJobsModal();
                updateInterruptedJobs();
                updateJobs();
            } catch (error) {
                alert(`Failed to resume jobs: ${error.message}`);
            }
        }

        // Failed Jobs Dropdown
        function toggleFailedJobsDropdown() {
            const list = document.getElementById('failed-jobs-list');
            list.classList.toggle('hidden');
        }

        function startFailedJobsUpdates() {
            updateFailedJobs();
            failedJobsInterval = setInterval(updateFailedJobs, 5000);
        }

        async function updateFailedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=failed');
                failedJobsData.jobs = data.jobs || [];
                renderFailedJobs();
            } catch (error) {
                console.error('Failed to update failed jobs:', error);
            }
        }

        function renderFailedJobs() {
            const dropdown = document.getElementById('failed-jobs-dropdown');
            const list = document.getElementById('failed-jobs-list');
            const count = document.getElementById('failed-count');

            if (failedJobsData.jobs.length === 0) {
                dropdown.classList.add('hidden');
                return;
            }

            dropdown.classList.remove('hidden');
            count.textContent = failedJobsData.jobs.length;

            list.innerHTML = failedJobsData.jobs.map(job => `
                <div class="failed-job-item">
                    <div class="failed-job-info">
                        Job #${job.job_id}: ${job.src_path} ‚Üí ${job.dst_path}
                        ${job.error_text ? '<br><span style="color: #dc3545; font-size: 11px;">' + job.error_text.substring(0, 100) + '...</span>' : ''}
                    </div>
                    <div class="failed-job-actions">
                        <button class="job-icon-btn resume" onclick="resumeFailedJobFromDropdown(${job.job_id})" title="Resume this job">‚ñ∂</button>
                        <button class="job-icon-btn cancel" onclick="cancelFailedJob(${job.job_id})" title="Cancel this job">√ó</button>
                    </div>
                </div>
            `).join('');
        }

        async function cancelFailedJob(jobId) {
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                updateFailedJobs();
            } catch (error) {
                alert(`Failed to cancel job: ${error.message}`);
            }
        }

        async function resumeFailedJobFromDropdown(jobId) {
            try {
                const data = await apiCall(`/api/jobs/${jobId}/resume`, 'POST');
                updateFailedJobs();
                updateJobs();  // Refresh active jobs too
            } catch (error) {
                alert(`Failed to resume job: ${error.message}`);
            }
        }

        // Quit server
        async function quitServer() {
            const runningCount = jobsData.jobs ? jobsData.jobs.length : 0;
            if (runningCount > 0) {
                const confirmed = confirm(
                    `‚ö†Ô∏è Warning: ${runningCount} job(s) are currently running.\n\n` +
                    `If you quit now, these jobs will be stopped and marked as interrupted.\n\n` +
                    `Are you sure you want to quit?`
                );
                if (!confirmed) return;
            }

            try {
                const data = await apiCall('/api/shutdown', 'POST');
                
                // Replace page content with shutdown message
                document.body.innerHTML = `
                    <div style="max-width:800px; margin:100px auto; text-align:center; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <h1 style="color:#28a745; margin-bottom:20px;">‚úì Server Stopped Successfully</h1>
                        <p style="font-size:18px; color:#666; margin-bottom:30px;">
                            The Motus server has been shut down gracefully.
                        </p>
                        ${data.running_jobs_stopped > 0 ?
                            `<p style="color:#666; margin-bottom:20px;">
                                ${data.running_jobs_stopped} running job(s) were stopped and marked as interrupted.
                                You can resume them next time you start the server.
                            </p>` : ''}
                        <p style="color:#999; font-size:14px;">
                            You can close this window now.
                        </p>
                    </div>
                `;
            } catch (error) {
                alert(`Failed to shutdown server: ${error.message}`);
            }
        }

        // Expert mode functions (existing)
        async function authenticate() {
            authToken = document.getElementById('token').value;
            document.cookie = `motus_token=${authToken}; path=/; max-age=31536000`;
            try {
                await apiCall('/api/health');
                document.getElementById('auth-status').innerHTML = '<div class="success">‚úì Authenticated successfully</div>';
            } catch (error) {
                document.getElementById('auth-status').innerHTML = `<div class="error">‚úó Authentication failed: ${error.message}</div>`;
            }
        }

        async function listRemotes() {
            try {
                const data = await apiCall('/api/remotes');
                document.getElementById('remotes-output').textContent = 
                    `Found ${data.count} remote(s):\n\n` + data.remotes.join('\n');
            } catch (error) {
                document.getElementById('remotes-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listFiles() {
            const path = document.getElementById('ls-path').value;
            try {
                const data = await apiCall('/api/files/ls', 'POST', { path });

                // Backend returns rclone's format: Name, Size, IsDir, ModTime
                const output = data.files.map(f => {
                    const type = f.IsDir ? 'DIR ' : 'FILE';
                    const size = f.IsDir ? '' : formatFileSize(f.Size);
                    return `${type} ${f.Name.padEnd(40)} ${size}`;
                }).join('\n');

                document.getElementById('ls-output').textContent = output || 'Empty directory';
            } catch (error) {
                document.getElementById('ls-output').textContent = `Error: ${error.message}`;
            }
        }

        async function makeDirectory() {
            const path = document.getElementById('mkdir-path').value;
            try {
                await apiCall('/api/files/mkdir', 'POST', { path });
                document.getElementById('mkdir-status').innerHTML = `<div class="success">‚úì Directory created: ${path}</div>`;
            } catch (error) {
                document.getElementById('mkdir-status').innerHTML = `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function deletePath() {
            const path = document.getElementById('delete-path').value;
            if (!confirm(`Are you sure you want to delete: ${path}?`)) return;
            
            try {
                await apiCall('/api/files/delete', 'POST', { path });
                document.getElementById('delete-status').innerHTML = `<div class="success">‚úì Deleted: ${path}</div>`;
            } catch (error) {
                document.getElementById('delete-status').innerHTML = `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function startCopyJob() {
            const src = document.getElementById('job-src').value.trim();
            const dst = document.getElementById('job-dst').value.trim();

            if (!src || !dst) {
                alert('Please provide both source and destination paths');
                return;
            }

            const copyLinks = document.getElementById('copy-links').checked;

            try {
                const data = await apiCall('/api/jobs/copy', 'POST', {
                    src_path: src,
                    dst_path: dst,
                    copy_links: copyLinks
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML =
                    `<div class="success">‚úì Copy job started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML =
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function resumeJobById() {
            const jobIdValue = document.getElementById('job-id').value.trim();
            const jobId = parseInt(jobIdValue);

            if (!jobId) {
                alert('Please enter a valid job ID');
                return;
            }

            try {
                const data = await apiCall(`/api/jobs/${jobId}/resume`, 'POST');
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML =
                    `<div class="success">‚úì Job resumed (New ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML =
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function startMoveJob() {
            const src = document.getElementById('job-src').value;
            const dst = document.getElementById('job-dst').value;
            
            try {
                const data = await apiCall('/api/jobs/move', 'POST', { 
                    src_path: src, 
                    dst_path: dst
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="success">‚úì Move job started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function checkIntegrity() {
            const src = document.getElementById('job-src').value;
            const dst = document.getElementById('job-dst').value;
            
            try {
                const data = await apiCall('/api/jobs/check', 'POST', { 
                    src_path: src, 
                    dst_path: dst
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="success">‚úì Integrity check started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        // Keep old function for compatibility (not used in UI anymore)
        async function resumeJob() {
            startCopyOrResumeJob();
        }

        async function syncJob() {
            const src = document.getElementById('job-src').value;
            const dst = document.getElementById('job-dst').value;
            
            if (!confirm(
                '‚ö†Ô∏è WARNING: Sync is a DESTRUCTIVE operation!\n\n' +
                'Files in the destination that don\'t exist in the source will be DELETED.\n\n' +
                'Are you sure you want to continue?'
            )) {
                return;
            }
            
            try {
                const data = await apiCall('/api/jobs/sync', 'POST', { 
                    src_path: src, 
                    dst_path: dst
                });
                document.getElementById('job-id').value = data.job_id;
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="success">‚úì Sync job started (ID: ${data.job_id})</div>`;
            } catch (error) {
                document.getElementById('job-start-status').innerHTML = 
                    `<div class="error">‚úó Error: ${error.message}</div>`;
            }
        }

        async function getJobStatus() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }

            try {
                const job = await apiCall(`/api/jobs/${jobId}`);
                const output = `
Job ID: ${job.job_id}
Operation: ${job.operation}
Status: ${job.status}
Progress: ${job.progress}%
Source: ${job.src_path}
Destination: ${job.dst_path}
Created: ${job.created_at}
${job.finished_at ? 'Finished: ' + job.finished_at : ''}
${job.error_text ? 'Error: ' + job.error_text : ''}

Output:
${job.text || '(no output yet)'}
                `.trim();
                document.getElementById('job-status-output').textContent = output;
            } catch (error) {
                document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
            }
        }

        async function showJobLog() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }

            try {
                const data = await apiCall(`/api/jobs/${jobId}/log`);
                const logText = data.log_text || '(no log available)';
                document.getElementById('job-status-output').textContent = `=== Job ${jobId} Log ===\n\n${logText}`;
            } catch (error) {
                document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
            }
        }

        // SSE Progress Watching
        let progressEventSource = null;

        function watchJobProgress() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }

            // Stop any existing connection
            stopWatchingProgress();

            // Build SSE URL with token
            const token = getToken();
            const baseUrl = window.location.origin;
            const sseUrl = `${baseUrl}/api/stream/jobs/${jobId}?token=${token}`;

            // Show watching indicator
            document.getElementById('watch-progress-btn').style.display = 'none';
            document.getElementById('stop-watch-btn').style.display = 'inline-block';
            document.getElementById('job-status-output').textContent = `üî¥ Watching job ${jobId} (real-time updates)...\n\n`;

            // Create EventSource connection
            progressEventSource = new EventSource(sseUrl);

            progressEventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);

                    if (data.error) {
                        document.getElementById('job-status-output').textContent = `Error: ${data.error}`;
                        stopWatchingProgress();
                        return;
                    }

                    // Format progress update
                    const timestamp = new Date().toLocaleTimeString();
                    const output = `
üî¥ LIVE UPDATE - ${timestamp}

Job ID: ${data.job_id}
Progress: ${data.progress}%
Status: ${data.finished ? 'Finished' : 'Running'}
Exit Status: ${data.exit_status}
${data.error_text ? 'Error: ' + data.error_text : ''}

Recent Output:
${data.text || '(no output yet)'}
                    `.trim();

                    document.getElementById('job-status-output').textContent = output;

                    // Auto-stop when job finishes
                    if (data.finished) {
                        setTimeout(() => {
                            stopWatchingProgress();
                            // Show completion status
                            const finalOutput = output.replace('üî¥ LIVE UPDATE', '‚úì Job Completed');
                            document.getElementById('job-status-output').textContent = finalOutput;
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error parsing SSE data:', error);
                }
            };

            progressEventSource.onerror = function(error) {
                console.error('SSE error:', error);
                document.getElementById('job-status-output').textContent += '\n\n‚ö†Ô∏è Connection lost. Click "Watch Progress" to reconnect.';
                stopWatchingProgress();
            };
        }

        function stopWatchingProgress() {
            if (progressEventSource) {
                progressEventSource.close();
                progressEventSource = null;
            }
            document.getElementById('watch-progress-btn').style.display = 'inline-block';
            document.getElementById('stop-watch-btn').style.display = 'none';
        }

        async function stopJob() {
            const jobId = document.getElementById('job-id').value;
            if (!jobId) {
                alert('Please enter a job ID');
                return;
            }
            
            try {
                await apiCall(`/api/jobs/${jobId}/stop`, 'POST');
                document.getElementById('job-status-output').textContent = `Job ${jobId} stopped`;
            } catch (error) {
                document.getElementById('job-status-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listAllJobs() {
            try {
                const data = await apiCall('/api/jobs');
                const output = data.jobs.map(j =>
                    `#${j.job_id} ${j.operation} ${j.status} ${j.progress}% - ${j.src_path} ‚Üí ${j.dst_path}`
                ).join('\n');
                document.getElementById('all-jobs-output').textContent = output || 'No jobs';
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listRunningJobs() {
            try {
                const data = await apiCall('/api/jobs?status=running');
                const output = data.jobs.map(j =>
                    `#${j.job_id} ${j.operation} ${j.progress}% - ${j.src_path} ‚Üí ${j.dst_path}`
                ).join('\n');
                document.getElementById('all-jobs-output').textContent = output || 'No running jobs';
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        async function listAbortedJobs() {
            try {
                const data = await apiCall('/api/jobs?status=aborted');
                const output = data.jobs.map(j =>
                    `#${j.job_id} ${j.operation} - ${j.src_path} ‚Üí ${j.dst_path}`
                ).join('\n');
                document.getElementById('all-jobs-output').textContent = output || 'No aborted jobs';
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        async function clearStoppedJobs() {
            if (!confirm('Clear all stopped jobs?')) return;

            try {
                const data = await apiCall('/api/jobs/clear-stopped', 'POST');
                document.getElementById('all-jobs-output').textContent =
                    `Cleared ${data.count} stopped job(s)`;
            } catch (error) {
                document.getElementById('all-jobs-output').textContent = `Error: ${error.message}`;
            }
        }

        // Arrow button functions
        function updateArrowButtons() {
            const leftBtn = document.getElementById('copy-left-btn');
            const rightBtn = document.getElementById('copy-right-btn');

            if (!leftBtn || !rightBtn) return;

            // Enable right arrow if left pane has selections
            if (leftPaneState.selectedIndexes.length > 0) {
                rightBtn.disabled = false;
                rightBtn.style.opacity = '1';
                rightBtn.style.cursor = 'pointer';
            } else {
                rightBtn.disabled = true;
                rightBtn.style.opacity = '0.3';
                rightBtn.style.cursor = 'not-allowed';
            }

            // Enable left arrow if right pane has selections
            if (rightPaneState.selectedIndexes.length > 0) {
                leftBtn.disabled = false;
                leftBtn.style.opacity = '1';
                leftBtn.style.cursor = 'pointer';
            } else {
                leftBtn.disabled = true;
                leftBtn.style.opacity = '0.3';
                leftBtn.style.cursor = 'not-allowed';
            }
        }

        async function copySelectedToRight() {
            if (leftPaneState.selectedIndexes.length === 0) return;

            // Build list of files and paths for confirmation
            const files = leftPaneState.selectedIndexes.map(index => leftPaneState.files[index]);
            const fileNames = files.map(f => f.Name);

            const sourcePath = leftPaneState.remote ?
                `${leftPaneState.remote}:${leftPaneState.path}` :
                leftPaneState.path;
            const destPath = rightPaneState.remote ?
                `${rightPaneState.remote}:${rightPaneState.path}` :
                rightPaneState.path;

            // Store pending operation and show confirmation
            pendingDragDrop = {
                sourcePane: 'left',
                targetPane: 'right',
                sourceState: leftPaneState,
                targetState: rightPaneState,
                indexes: leftPaneState.selectedIndexes,
                files: files
            };

            showDragDropConfirmModal(fileNames, sourcePath, destPath);
        }

        async function copySelectedToLeft() {
            if (rightPaneState.selectedIndexes.length === 0) return;

            // Build list of files and paths for confirmation
            const files = rightPaneState.selectedIndexes.map(index => rightPaneState.files[index]);
            const fileNames = files.map(f => f.Name);

            const sourcePath = rightPaneState.remote ?
                `${rightPaneState.remote}:${rightPaneState.path}` :
                rightPaneState.path;
            const destPath = leftPaneState.remote ?
                `${leftPaneState.remote}:${leftPaneState.path}` :
                leftPaneState.path;

            // Store pending operation and show confirmation
            pendingDragDrop = {
                sourcePane: 'right',
                targetPane: 'left',
                sourceState: rightPaneState,
                targetState: leftPaneState,
                indexes: rightPaneState.selectedIndexes,
                files: files
            };

            showDragDropConfirmModal(fileNames, sourcePath, destPath);
        }
    </script>
</body>
</html>
